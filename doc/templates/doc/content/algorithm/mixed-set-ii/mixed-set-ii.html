{% load static %}

<!-- Insert title here -->

<h1 id="mixedsetii">Mixed Set II</h1>

<h2 id="tableofcontents">Table of Contents</h2>

<ul>
<li><a href="#binarysearch">Binary Search</a>

<ul>
<li><a href="#searchthefirstandthelastelement">Search the First and the Last Element</a></li>
<li><a href="#searchinrotatedarray">Search in Rotated Array</a></li>
<li><a href="#searchmatrix">Search Matrix</a></li>
<li><a href="#findmininrotatedarray">Find Min in Rotated Array</a></li>
<li><a href="#findpeak">Find Peak</a></li>
</ul></li>
<li><a href="#twopointers">Two Pointers</a>

<ul>
<li><a href="#removeduplicates">Remove Duplicates</a></li>
<li><a href="#threesum">Three Sum</a></li>
<li><a href="#backspacestringcompare">Backspace String Compare</a></li>
<li><a href="#intervallistintersections">Interval List Intersections</a></li>
<li><a href="#containerwithmostwater">Container with Most Water</a></li>
</ul></li>
<li><a href="#slidewindow">Slide Window</a>

<ul>
<li><a href="#findallanagrams">Find All Anagrams</a></li>
</ul></li>
<li><a href="#bfsanddfs">BFS and DFS</a>

<ul>
<li><a href="#numberofislands">Number of Islands</a></li>
<li><a href="#numberofprovinces">Number of Provinces</a></li>
<li><a href="#subtreeofanothertree">Subtree of Another Tree</a></li>
<li><a href="#populatingpointers">Populating Pointers</a></li>
<li><a href="#shortestpathinbinarymatrix">Shortest Path in Binary Matrix</a></li>
<li><a href="#surroundedregions">Surrounded Regions</a></li>
<li><a href="#allpathsfromsourcetotarget">All Paths from Source to Target</a></li>
</ul></li>
<li><a href="#recursionandbacktracking">Recursion and Backtracking</a>

<ul>
<li><a href="#subsets">Subsets</a></li>
<li><a href="#subsetsii">Subsets II</a></li>
<li><a href="#permutationii">Permutation II</a></li>
<li><a href="#combinationsum">Combination Sum</a></li>
<li><a href="#combinationsumii">Combination Sum II</a></li>
<li><a href="#lettercombinationsofphonenumber">Letter Combinations Of Phone Number</a></li>
<li><a href="#generateparentheses">Generate Parentheses</a></li>
<li><a href="#wordsearch">Word Search</a></li>
</ul></li>
<li><a href="#dynamicprogramming">Dynamic Programming</a>

<ul>
<li><a href="#houserobberii">House Robber II</a></li>
<li><a href="#jumpgame">Jump Game</a></li>
<li><a href="#jumpgameii">Jump Game II</a></li>
<li><a href="#uniquepath">Unique Path</a></li>
<li><a href="#jumpgameiii">Jump Game III</a></li>
<li><a href="#jumpgameiv">Jump Game IV</a></li>
<li><a href="#longestpalindromesubstring">Longest Palindrome Substring</a></li>
<li><a href="#arithmeticslices">Arithmetic Slices</a></li>
<li><a href="#decodeways">Decode Ways</a></li>
<li><a href="#wordbreak">Word Break</a></li>
<li><a href="#longestincreasingsubsequence">Longest Increasing Subsequence</a></li>
<li><a href="#dpsummary">DP Summary</a></li>
<li><a href="#findnumberoflis">Find Number of LIS</a></li>
<li><a href="#longestcommonsubsequence">Longest Common Subsequence</a></li>
<li><a href="#deleteoperationfortwostrings">Delete Operation for Two Strings</a></li>
<li><a href="#editdistance">Edit Distance</a></li>
<li><a href="#coinchange">Coin Change</a></li>
<li><a href="#integerbreak">Integer Break</a></li>
</ul></li>
<li><a href="#bitmanipulation">Bit Manipulation</a>

<ul>
<li><a href="#rangebitwiseand">Range Bitwise AND</a></li>
</ul></li>
<li><a href="#others">Others</a>

<ul>
<li><a href="#shuffleanarray">Shuffle An Array</a></li>
<li><a href="#happynumber">Happy Number</a></li>
</ul></li>
</ul>

<p><TableEndMark></p>
<!-- DO NOT ADD EndOfTable MANUALLY -->

<section	id="binarysearch">
<h2>Binary Search</h2>

<section	id="searchthefirstandthelastelement">
<h3>Search the First and the Last Element</h3>

<blockquote>
<p>Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. </p>

<p>If target is not found in the array, return [&#8211;1, &#8211;1]. </p>

<p>You must write an algorithm with O(log n) runtime complexity.</p>
</blockquote>

<p>The key to the problem is how to refine or design naive binary search. How to design a binary search that can search the index of the first target</p>

<p>The trick is trying to detect neighboring element. For the case of finding the first target.</p>
<pre><code class="cpp">// ...binary search code...
    if (nums[mid] == target) {
        // try to detect
        if ((mid &gt; 0) &amp;&amp; (nums[mid-1] == target)) {
            // not the first! continue to search in the left half
            r = mid - 1;
        }
        else {
            break;
        }
    }
// ...rest code...</code></pre>

<p>Similarly, we can design a binary search finding the last target.</p>
<pre><code class="cpp">vector&lt;int&gt; searchRange_sol2(vector&lt;int&gt; nums, int target) {
    if (nums.size() == 0) return {-1, -1};
    vector&lt;int&gt; result;
    // TODO: binary search for the first target
    int l = 0;
    int r = nums.size() - 1;
    int mid = 0;
    while (l &lt;= r) {
        mid = l + ((r - l) &gt;&gt; 1);
        if (nums[mid] == target) {
            if ((mid &gt; 0) &amp;&amp; (nums[mid-1] == target)) {
                r = mid - 1;
            }
            else {
                // mid is the first
                break;
            }
        }
        else if (nums[mid] &gt; target) {
            r = mid - 1;
        }
        else {
            l = mid + 1;
        }
    }
    if (l &gt; r) return {-1, -1};
    result.push_back(mid);

    // TODO: binary search for the last target
    l = 0; r = nums.size() - 1;
    while (l &lt;= r) {
        mid = l + ((r - l) &gt;&gt; 1);
        if (nums[mid] == target) {
            if ((mid &lt; nums.size() - 1) &amp;&amp; (nums[mid+1] == target)) {
                l = mid + 1;
            }
            else {
                break;
            }
        }
        else if (nums[mid] &lt; target) {
            l = mid + 1;
        }
        else {
            r = mid - 1;
        }
    }
    if (l &gt; r) return {-1, -1};
    result.push_back(mid);

    return result;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Change the behavior of binary search.</li>
</ul>

</section>
<section	id="searchinrotatedarray">
<h3>Search in Rotated Array</h3>

<blockquote>
<p>There is an integer array nums sorted in ascending order (with distinct values). </p>

<p>Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &lt;= k &lt; nums.length) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. </p>

<p>Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or &#8211;1 if it is not in nums. </p>

<p>You must write an algorithm with O(log n) runtime complexity.</p>
</blockquote>

<p>This problem gives us a deep understanding of binary search, also called one half known binary search. If the range of one half can be determined, then we can apply binary search to that problem.</p>
<pre><code class="cpp">/**
 * The key point is determine range!
 *
 * ex&gt;  4,  5,  6,  7,  0,  1,  2
 *      ^           ^   ^       ^
 *      |--sorted---|   |sorted-|
 *    begin                    end
 *
 * Case 1: if nums[mid] &gt;= nums[begin] which is 4, then
 *      4,  5,  6,  7,  0,  1,  2
 *          ^
 *         mid
 *      |---|-------------------|
 *      sorted     unsorted
 * if (nums[mid] &gt; target &gt; nums[begin]), then we will search in sorted half,
 * great! do as normal. otherwise, we will search in unsorted half, move begin
 * to mid + 1
 *
 * Case 2: if nums[mid] &lt; nums[begin], then (notice mid == begin cann&apos;t be
 * categorized in this case)
 *      4,  5,  6,  7,  0,  1,  2
 *                          ^
 *                         mid
 *      |-----unsorted------|---|
 *                          sorted
 * if (nums[mid] &lt; target &lt; nums[end]), search sorted part, otherwise, search
 * unsorted part.
 */</code></pre>
<pre><code class="cpp">int search_sol2(vector&lt;int&gt;&amp; nums, int target) {
    if (nums.size() == 0) return -1;
    int begin = 0;
    int end = nums.size() - 1;
    int mid = 0;
    while (begin &lt;= end) {
        mid = begin + ((end - begin) &gt;&gt; 1);
        if (nums[mid] == target) {
            return mid;
        }
        else {
            if (nums[mid] &gt;= nums[begin]) {
                if ((nums[mid] &gt; target) &amp;&amp; (target &gt;= nums[begin])) {
                    end = mid - 1;
                }
                else {
                    begin = mid + 1;
                }
            }
            else {
                if ((nums[mid] &lt; target) &amp;&amp; (target &lt;= nums[end])) {
                    begin = mid + 1;
                }
                else {
                    end = mid - 1;
                }
            }
        }
    }

    return -1;
}</code></pre>

<p>BTW, another way to solve the problem is transfer rotated array back to a completely sorted array, and apply binary search to it.</p>
<pre><code class="cpp">int search_sol1(vector&lt;int&gt;&amp; nums, int target) {
    if (nums.size() == 0) return -1;
    vector&lt;int&gt; vec;
    // TODO: find sorted array
    vec.insert(vec.end(), nums.begin(), nums.end());
    vec.insert(vec.end(), nums.begin(), nums.end());
    // return the index of min value
    int begin = min_element(nums.begin(), nums.end()) - nums.begin();
    int end = begin + nums.size() - 1;

    // TODO: binary search on vec[begin, end];
    int left = begin;
    int right = end;
    int mid = 0;
    while (left &lt;= right) {
        mid = left + ((right - left) &gt;&gt; 1);
        if (vec[mid] == target) {
            // find index in rotated array
            return mid % nums.size();
        }
        else if (vec[mid] &lt; target) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }
    return -1;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>The condition of using binary search: range of one half is known.</li>
<li><code>std::min_element(v.begin(), v.end())</code>: return iter for minimum element.</li>
<li><code>vector.insert(vector.end(), other.begin(), other.end())</code>: insert other to the end of <code>vector</code>.</li>
</ul>

</section>
<section	id="searchmatrix">
<h3>Search Matrix</h3>

<blockquote>
<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: </p>

<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
</blockquote>

<p>This ia a variant of binary search. We are solve the problem by two cooperative binary search.</p>
<pre><code class="cpp">/**
 * ex&gt; {1, 3, 5, 7},     &lt;--- top
 *     {10, 11, 16, 20},
 *     {23, 30, 34, 60}  &lt;--- bottom
 *      ^           ^
 *     left        right
 */</code></pre>

<p>Search row first and then search column.</p>
<pre><code class="cpp">bool searchMatrix_sol2(vector&lt; vector&lt;int&gt; &gt;&amp; matrix, int target) {
    int top = 0;
    int bottom = matrix.size() - 1;
    int left = 0;
    int last = matrix[0].size() - 1;
    int right = last;
    int midRow = 0;
    int midCol = 0;
    while (top &lt;= bottom) {
        midRow = top + ((bottom - top) &gt;&gt; 1);
        if (matrix[midRow][0] &gt; target) {
            bottom = midRow - 1;
        }
        else if (matrix[midRow][last] &lt; target) {
            top = midRow + 1;
        }
        else {
            // TODO: binary search in midRow
            while (left &lt;= right) {
                midCol = left + ((right - left) &gt;&gt; 1);
                if (matrix[midRow][midCol] == target) {
                    return true;
                }
                else if (matrix[midRow][midCol] &lt; target) {
                    left = midCol + 1;
                }
                else {
                    right = midCol - 1;
                }
            }
            return false;
        }
    }
    return false;
}</code></pre>

</section>
<section	id="findmininrotatedarray">
<h3>Find Min in Rotated Array</h3>

<blockquote>
<p>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: </p>

<ul>
<li>[4,5,6,7,0,1,2] if it was rotated 4 times.</li>
<li>[0,1,2,4,5,6,7] if it was rotated 7 times.</li>
</ul>

<p>Notice that rotating an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>. </p>

<p>Given the sorted rotated array nums of unique elements, return the minimum element of this array. </p>

<p>You must write an algorithm that runs in O(log n) time.</p>
</blockquote>

<p>Agian O(log n) implies our old friend binary search. There are two scenarioes:</p>

<ul>
<li>Array is rotated by 0 step.</li>
<li>Array is rotated by n steps, where n &gt; 0.</li>
</ul>
<pre><code class="cpp">/**
 * I. Sorted array is rotated by 0 steps
 * ex&gt; nums = {1, 2, 3, 4, 5}  when nums[left] &lt; nums[right], just return nums[left]
 *             ^           ^
 *            left        right
 *
 * II. Sorted array is rotated by n steps
 * ex&gt; nums = {4, 5, 6, 7, 8, 1, 2, 3}  when nums[left] &gt; nums[right]
 *             ^                    ^
 *            left                right
 *
 * Case 1: if nums[mid] &gt; nums[left], the minimum must lie in unsorted half
 *     nums = {4, 5, 6, 7, 8, 1, 2, 3}
 *             ^        ^           ^
 *            left     mid         right
 *            |--sorted-|--unsorted--|
 *                       exclude mid
 *
 * Case 2: if nums[mid] &lt; nums[left], the minimum must lie in unsorted half
 *     nums = {4, 5, 6, 7, 8, 1, 2, 3}
 *             ^                 ^  ^
 *            left              mid right
 *            |-----unsorted-----|---|
 *              include mid      sorted
 *
 * Case 3: if nums[mid] == nums[left], the minimum number is mid + 1
 *     nums = {4, 1, 2, 3}
 *             ^        ^
 *            left      right
 *            mid
 */</code></pre>

<p>So let&#8217;s re-design our binary search.</p>
<pre><code class="cpp">int findMin_sol1(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0) return INT_MAX;
    int left = 0;
    int right = nums.size() - 1;
    int mid = 0;
    while (left &lt;= right) {
        // TODO: array without rotated
        if (nums[left] &lt;= nums[right]) return nums[left];
        // TODO: array is rotated
        mid = left + ((right - left) &gt;&gt; 1);
        if (nums[mid] == nums[left]) {
            return nums[mid + 1];
        }
        else if (nums[mid] &gt; nums[left]) {
            left = mid + 1; // exclude middle
        }
        else {
            right = mid; // include middle
        }
    }

    return INT_MAX;
}</code></pre>

<p>Similarly, we are able to find maximum number with binary search. The logic can be summarized as follows.</p>

<ul>
<li>Not rotated: if nums[left] &lt; nums[right] return nums[right]</li>
<li>Rotated:

<ul>
<li>nums[mid] &gt; nums[left], then search in right part, nums[mid] included.</li>
<li>nums[mid] &lt; nums[left], then search in left part, nums[mid] excluded.</li>
<li>nums[mid] == nums[left], return nums[mid]</li>
</ul></li>
</ul>
<pre><code class="cpp">int findMax_sol1(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0) return INT_MIN;
    int left = 0;
    int right = nums.size() - 1;
    int mid = 0;
    while (left &lt;= right) {
        // TODO: array without rotated
        if (nums[left] &lt;= nums[right]) return nums[right];
        // TODO: array is rotated
        mid = left + ((right - left) &gt;&gt; 1);
        if (nums[mid] == nums[left]) {
            return nums[mid];
        }
        else if (nums[mid] &gt; nums[left]) {
            left = mid; // include middle
        }
        else {
            right = mid - 1; // exclude middle
        }
    }

    return INT_MIN;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Divide and conquer plus binary search.</li>
</ul>

</section>
<section	id="findpeak">
<h3>Find Peak</h3>

<blockquote>
<p>A peak element is an element that is strictly greater than its neighbors. </p>

<p>Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. </p>

<p>You may imagine that nums[&#8211;1] = nums[n] = -âˆž. </p>

<p>You must write an algorithm that runs in O(log n) time.</p>
</blockquote>

<p>What&#8217;s the feature of peak point? its neighboring number must be smaller than it. How to find peak with binary search? There are two cases:</p>
<pre><code class="cpp">/**
 * Case 1: nums = {1, 2, 3, 4, 5}
 *                        ^     ^
 *                       mid   peak
 *  If mid is facing uphill (nums[mid] &lt;= nums[mid+1]), then peak must be in the
 *  right side (excluded).
 * Case 2: nums = {5, 4, 3, 2, 1}
 *                  ^     ^
 *                 peak  mid
 *  On the contrary, if mid is facing downhill nums[mid] &gt; nums[mid+1], the peak
 *  must be in the left side (included).</code></pre>

<p>So we are able to design our binary search. <code>left</code> and <code>right</code> will converge at peak.</p>
<pre><code class="cpp">int findPeakElement_sol1(vector&lt;int&gt;&amp; nums) {
    // TODO: fill boundaries
    nums.insert(nums.begin(), INT_MIN);
    nums.insert(nums.end(), INT_MIN);
    int left = 1;
    int right = nums.size() - 2;
    int mid = 0;
    while (left &lt; right) {
        mid = left + ((right - left) &gt;&gt; 1);
        // TODO: where am i
        if (nums[mid] &gt; nums[mid+1]) {
            right = mid;
        }
        else {
            left = mid + 1;
        }
    }

    return left - 1; // shift boundary
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Determine searching range.</li>
</ul>

</section>
</section>
<section	id="twopointers">
<h2>Two Pointers</h2>

<section	id="removeduplicates">
<h3>Remove Duplicates</h3>

<blockquote>
<p>Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.</p>
</blockquote>

<p>The first solution is a O(N) solution. We will traverse the list with two pointers. The first pointer &#8216;cur&#8217; points to the node being examined, and the second pointer &#8216;probe&#8217; will explore the nodes follow &#8216;cur&#8217; node. &#8216;cur&#8217; node is also known as sentinel.</p>

<ul>
<li>Initialize cur and probe as shown above.</li>
<li>Use probe to find the next node with different value from that of current node.</li>
<li>If <code>probe != cur-&gt;next</code>, then DUPLICATES! move cur to probe, probe move forward by 1 step. Else, append cur in our new list and move cur to probe, probe move forward.</li>
</ul>
<pre><code class="cpp">ListNode* deleteDuplicates_sol1(ListNode* head) {
    // TODO: corner cases
    if ((head == nullptr) || (head-&gt;next == nullptr)) return head;

    ListNode* newList = new ListNode(); // for convenience
    ListNode* endOfNewList = newList;
    ListNode* cur = head;
    ListNode* probe = cur-&gt;next;
    while (true) {
        while ((probe != nullptr) &amp;&amp; (probe-&gt;val == cur-&gt;val)) {
            probe = probe-&gt;next;
        }
        if (cur-&gt;next == probe) {
            // TODO: append to the end of list
            ListNode* node = new ListNode(cur-&gt;val);
            endOfNewList-&gt;next = node;
            endOfNewList = node;
        }
        cur = probe;
        if (cur == nullptr) { // the last case
            break;
        }
        probe = cur-&gt;next;
    }

    return newList-&gt;next; // get rid of the first null node.
}</code></pre>

</section>
<section	id="threesum">
<h3>Three Sum</h3>

<blockquote>
<p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>. </p>

<p>Notice that the solution set must not contain duplicate triplets.</p>
</blockquote>

<p>Two Sum and Three Sum share a similarity that the sum of elements must match the target exactly. A difference is that, instead of exactly one answer, we need to find all unique triplets that sum to zero. Before jumping in, let&#8217;s check the existing solutions and determine the best conceivable runtime (BCR) for 3Sum:</p>

<ul>
<li>unordered two sum: it can be solved with a hash map with time complexity of O(N) and space complexity of O(N).</li>
<li>ordered two sum: we are able to deal with it for O(N) by using two pointers. If original array is unordered, we need O(logN) extra time, thereby the total time complexity is O(N + logN).</li>
</ul>

<p>Considering that there is one more dimension in 3Sum, it sounds reasonable to shoot for O(N<sup>2</sup>).</p>

<p>Based on ordered two sum, we can solve three sum conveniently. But we have to take into consideration how to get rid of duplicates.</p>

<p>Now let&#8217;s discuss how to make sure duplicates will not occur:</p>

<ul>
<li>hashset: if the same number is processed before, then skip it.</li>
<li>order: process from left to right, for example, if <code>nums[i]</code> is processed, then we will find solution from <code>i+1</code> to <code>end</code> for numbers within <code>[0, i-1]</code> may be in the solution before, and <code>-nums[i]</code> is our target. See example below.</li>
<li>optimize: <code>if (nums[i] &gt; 0)</code>, then there is no need to proceed as all numbers after nums[i] are positive, and their combination can NOT be zero.</li>
</ul>
<pre><code class="cpp">/**
 *  nums = {-1, 0, 1, 2, 3}
 *                 ^
 *                 i
 *  if we find solution in [begin, i) and (i, end], then we will find one solution (-1, 0, 1),
 *  which happens to be one solution when we process nums[0] (-1).
 */</code></pre>

<p>From another aspect, for an solution <code>(-1, 0, 1)</code>, it can be produced when we process &#8211;1, 0, 1 respectively. Therefore, we keep find solution in <code>[i+1, end]</code></p>
<pre><code class="cpp">vector&lt; vector&lt;int&gt; &gt; twoSum_pointers(vector&lt;int&gt;&amp; nums, int targetIndex) {
    vector&lt; vector&lt;int&gt; &gt; result;
    int left = targetIndex + 1;
    int right = nums.size() - 1;
    int target = -nums[targetIndex];
    while (left &lt; right) {
        if (nums[left] + nums[right] &gt; target) {
            right--;
        }
        else if (nums[left] + nums[right] &lt; target) {
            left++;
        }
        else {
            // TODO: find one solution
            result.push_back({-target, nums[left], nums[right]});
            right--;
            // avoid duplicate: move left to next different val
            int next = left + 1;
            while ((next &lt; right) &amp;&amp; (nums[next] == nums[left])) {
                next++;
            }
            left = next;
        }
    }

    return result;
}

vector&lt; vector&lt;int&gt; &gt; threeSum_sol2(vector&lt;int&gt;&amp; nums) {
    unordered_set&lt;int&gt; seen;
    vector&lt; vector&lt;int&gt; &gt; result;
    vector&lt; vector&lt;int&gt; &gt; subResult;
    sort(nums.begin(), nums.end());

    for (int i = 0; i &lt; nums.size(); i++) {
        if (nums[i] &gt; 0) break;
        if (seen.find(nums[i]) != seen.end()) continue;
        seen.insert(nums[i]);
        subResult = twoSum_pointers(nums, i);
        result.insert(result.end(), subResult.begin(), subResult.end());
    }

    return result;
}</code></pre>

<p>Similarly, for unsorted nums, we can solve it by hashtable. But question here is how to git rid of duplicates of triplets. One solution is by hashset.</p>

<ul>
<li>If one solution is found, then put all combination of the solution into hashset.</li>
<li>Before we insert one solution into <code>result</code>, check if it is in the hashset.</li>
</ul>

<p>Tricks:</p>

<ul>
<li>STL funtions: c <code>qsort</code> and c++ <code>sort</code> in <code>&lt;stdlib.h&gt;</code></li>
</ul>
<pre><code class="cpp">#include &lt;stdlib.h&gt;

// C style
int myCompare_C(const void* lhs, const void* rhs) {
    return (*(int*)lhs - *(int*)rhs);
    /**
     * // Descending order: same to following if clauses
     * if (*(int*)lhs &gt; *(int*)rhs) return 1;
     * if (*(int*)lhs == *(int*)rhs) return 0;
     * if (*(int*)lhs &lt; *(int*)lhs) return -1;
     */
}

// C++ style
bool myCompare(int lhs, int rhs) {
    return (lhs &gt; rhs);
}

// Calling:

sort(nums.begin(), nums.end()); // non-descending order
sort(nums.begin(), nums.end(), myCompare); // non-ascending order

qsort(arr, size, sizeof(type), compareFunc);</code></pre>

</section>
<section	id="backspacestringcompare">
<h3>Backspace String Compare</h3>

<blockquote>
<p>Given two strings s and t, return true if they are equal when both are typed into empty text editors. &#8216;#&#8217; means a backspace character. </p>

<p>Note that after backspacing an empty text, the text will continue empty.</p>
</blockquote>

<p>The basic idea is to simulate backspace operation on original string, and then check two strings.</p>
<pre><code class="cpp">bool backspaceCompare_sol2(string s, string t) {
    stack&lt;char&gt; ss;
    stack&lt;char&gt; tt;
    for (int i = 0; i &lt; s.size(); i++) {
        if ((s[i] == &apos;#&apos;) &amp;&amp; (!ss.empty())) {
            ss.pop();
        }
        if (s[i] != &apos;#&apos;) {
            ss.push(s[i]);
        }
    }
    for (int i = 0; i &lt; t.size(); i++) {
        if ((t[i] == &apos;#&apos;) &amp;&amp; (!tt.empty())) {
            tt.pop();
        }
        if (t[i] != &apos;#&apos;) {
            tt.push(t[i]);
        }
    }

    while ((!ss.empty()) &amp;&amp; (!tt.empty())) {
        if (ss.top() != tt.top()) {
            return false;
        }
        ss.pop();
        tt.pop();
    }

    if ((!ss.empty()) || (!tt.empty())) {
        return false;
    }

    return true;
}</code></pre>

<p>Another way is also pretty straightforward but slightly complicated.</p>

<p>The algorithm is to scan string from the end to begin with two pointers to two strings perspectively.</p>

<ul>
<li>find the first non-&#8216;#&#8217; character.</li>
<li>then there are three cases:

<ul>
<li>both pointers are not reaching the end. (depending on)</li>
<li>one of them reaches the end. (false)</li>
<li>both of them reaches the end. (true)</li>
</ul></li>
</ul>
<pre><code class="cpp">bool backspaceCompare_sol1(string s, string t) {
    string::reverse_iterator it_s = s.rbegin();
    string::reverse_iterator it_t = t.rbegin();
    stack&lt;char&gt; ss;
    stack&lt;char&gt; st;
    while ((it_s != s.rend()) || (it_t != t.rend())) {
        // TODO: find the first character remain in s from the end
        while ((it_s != s.rend()) &amp;&amp; (*it_s == &apos;#&apos;)) {
            while ((*it_s == &apos;#&apos;) &amp;&amp; (it_s != s.rend()))  {
                ss.push(*it_s);
                it_s++;
            }
            while ((!ss.empty()) &amp;&amp; (*it_s != &apos;#&apos;) &amp;&amp; (it_s != s.rend())) {
                ss.pop();
                it_s++;
            }
        }

        // TODO: find the first character remain in s from the end
        while ((it_t != t.rend()) &amp;&amp; (*it_t == &apos;#&apos;)) {
            while ((*it_t == &apos;#&apos;) &amp;&amp; (it_t != t.rend())) {
                st.push(*it_t);
                it_t++;
            }
            while ((!st.empty()) &amp;&amp; (*it_t != &apos;#&apos;) &amp;&amp; (it_t != t.rend())) {
                st.pop();
                it_t++;
            }
        }

        // TODO: case 1
        if ((it_s != s.rend()) &amp;&amp; (it_t != t.rend())) {
            if (*it_s != *it_t) {
                return false;
            }
            else {
                it_s++;
                it_t++;
                continue;
            }
        }
        // TODO: case 2 &amp; 3
        if ((it_s == s.rend()) &amp;&amp; (it_t == t.rend())) {
            return true;
        }
        else {
            return false;
        }
    }

    return true; // both s and t are blank strings
}</code></pre>

<p>Tricks:</p>

<ul>
<li>ALWAYS checking the end of iterator if <code>++</code> or <code>--</code>.</li>
<li>Distinguish <code>rbegin()</code> and <code>rend()</code> from <code>cbegin()</code> and <code>cend()</code>, where <code>c</code> means const.</li>
</ul>

</section>
<section	id="intervallistintersections">
<h3>Interval List Intersections</h3>

<blockquote>
<p>You are given two lists of closed intervals, firstList and secondList, where <code>firstList[i] = [starti, endi]</code> and <code>secondList[j] = [startj, endj]</code>. Each list of intervals is pairwise disjoint and in sorted order. </p>

<p>Return the intersection of these two interval lists. </p>

<p>A closed interval <code>[a, b] (with a &lt;= b)</code> denotes the set of real numbers x with <code>a &lt;= x &lt;= b</code>. </p>

<p>The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].</p>
</blockquote>

<p>The idea of solution 1 is pretty straightforward, which is to simulate intersections with an array. Project A and B to array, and the elements with value 2 consist of intersection list.</p>

<p>If <code>intersection[i]</code> is greater than 0, then interval [i, i+1) is painted. </p>

<p>But the limitation of this method is that it can only find the interval except intersection points. To fix that, we use a hashmap to find intersection points.</p>
<pre><code class="cpp">vector&lt; vector&lt;int&gt; &gt; intervalIntersection_sol1(vector&lt; vector&lt;int&gt; &gt;&amp; firstList, vector&lt; vector&lt;int&gt; &gt;&amp; secondList) {
    int max_size = 1002;
    unordered_map&lt;int, int&gt; points;
    vector&lt;int&gt; intersection(max_size);
    vector&lt; vector&lt;int&gt; &gt; result;
    for (int i = 0; i &lt; firstList.size(); i++) {
        if (points.find(firstList[i][0]) == points.end()) {
            points[firstList[i][0]] = 1;
        }
        else {
            points[firstList[i][0]]++;
        }
        if (points.find(firstList[i][1]) == points.end()) {
            points[firstList[i][1]] = 1;
        }
        else {
            points[firstList[i][1]]++;
        }
        for (int j = firstList[i][0]; j &lt; firstList[i][1]; j++) {
            intersection[j]++;
        }
    }
    for (int i = 0; i &lt; secondList.size(); i++) {
        if (points.find(secondList[i][0]) == points.end()) {
            points[secondList[i][0]] = 1;
        }
        else {
            points[secondList[i][0]]++;
        }
        if (points.find(secondList[i][1]) == points.end()) {
            points[secondList[i][1]] = 1;
        }
        else {
            points[secondList[i][1]]++;
        }
        for (int j = secondList[i][0]; j &lt; secondList[i][1]; j++) {
            intersection[j]++;
        }
    }

    // TODO: push overlap points into result
    for (auto pair : points) {
        if (pair.second &gt;= 2) {
            result.push_back({pair.first, pair.first});
        }
    }

    // TODO: construct output with two pointers, interval [l, r)
    int l = 0;
    int r = 0;
    int length = max(firstList[firstList.size()-1][1], secondList[secondList.size()-1][1]);
    while (l &lt;= length) {
        // TODO: move l to the next 2
        while ((intersection[l] != 2) &amp;&amp; (l &lt; length)) {
            l++;
        }
        r = l;
        // TODO: r explore the end of consecutive 2
        while ((intersection[r] == 2) &amp;&amp; (r &lt; length)) {
            r++;
        }
        if (l &lt; length) {
            result.push_back({l, r});
        }
        else {
            break;
        }
        l = r;
    }

    return result;
}</code></pre>

<p>The second solution is based on two observations below. Define: interval [a, b], b as endpoint of an interval.</p>
<pre><code class="cpp">/**
 * ex&gt;    list A:  -----    ---------  --------      --------
 *        list B: ---      ----- --------- ---- ---  ----
 *                  ^
 *  intersection:  -- ,which is {max(A[0][0], B[0][0]), min(A[0][1], B[0][1])}
 *                  ^
 */</code></pre>

<ul>
<li>the interval with smallest endpoint will intersect with only one interval in the other list.</li>
<li>the interval with smallest endpoint will share the same endpoint with intersection interval.</li>
</ul>
<pre><code class="cpp">vector&lt; vector&lt;int&gt; &gt; intervalIntersection_sol2(vector&lt; vector&lt;int&gt; &gt;&amp; firstList, vector&lt; vector&lt;int&gt; &gt;&amp; secondList) {
    vector&lt; vector&lt;int&gt; &gt; result;
    int pa = 0;
    int pb = 0;
    while ((pa &lt; firstList.size()) &amp;&amp; (pb &lt; secondList.size())) {
        // TODO: find interval with smallest endpoint
        int l = max(firstList[pa][0], secondList[pb][0]);
        int r = min(firstList[pa][1], secondList[pb][1]);
        if (l &lt;= r) {
            result.push_back({l, r});
        }
        (firstList[pa][1] &lt; secondList[pb][1]) ? pa++ : pb++;
    }

    return result;
}</code></pre>

</section>
<section	id="containerwithmostwater">
<h3>Container with Most Water</h3>

<blockquote>
<p>Given n non-negative integers <code>a1, a2, ..., an</code>, where each represents a point at coordinate <code>(i, ai)</code>. n vertical lines are drawn such that the two endpoints of the line i is at <code>(i, ai)</code> and <code>(i, 0)</code>. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water. </p>

<p>Notice that you may not slant the container.</p>
</blockquote>

<p>The equaltion for water area is <code>area = min(height[l], height[r]) * (r - l)</code>. Our goal is maximum two operands on the two sides of <code>*</code> sign.</p>

<p>We will use greedy algorithm to solve it.</p>

<ol>
<li>Set two pointers to at the leftmost and rightmost index of pillars where we maximize &#8216;(r - l)&#8217;.</li>
<li>Move r to left and l to right respectively.

<ul>
<li>if height[r&#8211;1] &lt; height[r], then jump it, since the second operand get smaller but the first remain same at best.</li>
<li>same operation to <code>l</code> as it moves to right.</li>
</ul></li>
</ol>

<p>Unfortunately, the time complexity for the algorithm above is O(N<sup>2</sup>). Our improvement is based on other fact: If left do not change and only move right pillar when the height of right pillar is higher than left one, the water area will get smaller.</p>
<pre><code class="cpp">/**
 * ex&gt;  1  2  3  5  3  2  1
 *      ^                 ^
 *     left         &lt;-- right
 *
 * When right go from 1 to 5, (r - l) get smaller, and min(height[l], height[r])
 * do NOT change!
 */</code></pre>

<p>Summary:</p>

<ul>
<li>maximize min(height[l], height[r]): move smaller one such that it can be greater.</li>
<li>maximize (r - l): starting from leftmost and rightmost.</li>
</ul>
<pre><code class="cpp">int maxArea_sol1(vector&lt;int&gt;&amp; height) {
    if (height.size() &lt; 2) return 0;
    int l = 0;
    int r = height.size() - 1;
    int maxArea = min(height[l], height[r]) * (r - l);
    int area = 0;
    while (l &lt; r) {
        if (height[l] &lt;= height[r]) {
            // TODO: move to next greater one
            int leftHeight = height[l];
            while ((l &lt; r) &amp;&amp; (leftHeight &gt;= height[l])) {
                l++;
            }
        }
        else {
            int rightHeight = height[r];
            while ((l &lt; r) &amp;&amp; (height[r] &lt;= rightHeight)) {
                r--;
            }
        }
        // TODO: update maxArea
        if (l &lt; r) {
            area = min(height[l], height[r]) * (r - l);
            maxArea = area &gt; maxArea ? area : maxArea;
        }
    }

    return maxArea;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Observation and find patterns.</li>
</ul>

</section>
</section>
<section	id="slidewindow">
<h2>Slide Window</h2>

<section	id="findallanagrams">
<h3>Find All Anagrams</h3>

<blockquote>
<p>Given two strings s and p, return an array of all the start indices of p&#8217;s anagrams in s. You may return the answer in any order. </p>

<p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
</blockquote>

<p>Solution 1 uses the method called move and query. We will build a set to store the permutation of string p, and make a window slide from left to right. At each step query if substring within window is in set. If so, got it!</p>

<p>But the time complexity of enumerating all permutations is O(N!)</p>

<p>The key here is frequency. So solution 2 will design two vecotrs to record frequency of s and p.</p>
<pre><code class="cpp">/**
 * ex&gt;  cbaebabacd     p = abc
 *   fp = &apos;1110000...000&apos;
 *         ^^^
 *         abcdefg...xyz
 *   fs = &apos;1110000...000&apos;
 *         ^^^
 *         abcdefg...xyz
 * window &apos;cbaebabacd&apos;
 *         ^ ^
 */</code></pre>
<pre><code class="cpp">vector&lt;int&gt; findAnagrams_sol2(string s, string p) {
    if (p.length() &gt; s.length()) return {};
    vector&lt;int&gt; result;
    vector&lt;int&gt; ss(26, 0);
    vector&lt;int&gt; sp(26, 0);
    for (int i = 0; i &lt; p.length(); i++) {
        sp[p[i] - &apos;a&apos;]++;
        ss[s[i] - &apos;a&apos;]++;
    }

    int begin = 0;
    int end = begin + p.length();
    while (end &lt;= s.length()) {
        if (sp == ss) {
            result.push_back(begin);
        }
        ss[s[begin] - &apos;a&apos;]--;
        if (end &lt; s.length()) {
            ss[s[end] - &apos;a&apos;]++;
        }
        begin++;
        end++;
    }

    return result;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>vector comparison: <code>sp == ss</code>.</li>
</ul>

</section>
</section>
<section	id="bfsanddfs">
<h2>BFS and DFS</h2>

<section	id="numberofislands">
<h3>Number of Islands</h3>

<blockquote>
<p>Given an m x n 2D binary grid grid which represents a map of &#8217;1&#8217;s (land) and &#8217;0&#8217;s (water), return the number of islands. </p>

<p>An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
</blockquote>

<p>This is a variant problem for Maximum Area of Islands. The solution is similar by BFS.</p>
<pre><code class="cpp">/**
 * @brief tagIsland
 * @param grid: the map
 * @param isTagged: record if point is tagged
 * @param i: row index of starting point
 * @param j: column index of starting point
 * tag all points within an island with BFS.
 */
void tagIsland(vector&lt; vector&lt;char&gt; &gt;&amp; grid,
               vector&lt; vector&lt;bool&gt; &gt;&amp; isTagged, int i, int j) {
    isTagged[i][j] = true;
    if ((i + 1 &lt; isTagged.size()) &amp;&amp; (grid[i+1][j] == &apos;1&apos;) &amp;&amp; (!isTagged[i+1][j]))
        tagIsland(grid, isTagged, i+1, j);
    if ((i - 1 &gt;= 0) &amp;&amp; (grid[i-1][j] == &apos;1&apos;) &amp;&amp; (!isTagged[i-1][j]))
        tagIsland(grid, isTagged, i-1, j);
    if ((j + 1 &lt; isTagged[0].size()) &amp;&amp; (grid[i][j+1] == &apos;1&apos;) &amp;&amp; (!isTagged[i][j+1]))
        tagIsland(grid, isTagged, i, j+1);
    if ((j - 1 &gt;= 0) &amp;&amp; (grid[i][j-1] == &apos;1&apos;) &amp;&amp; (!isTagged[i][j-1]))
        tagIsland(grid, isTagged, i, j-1);

    return;
}

/**
 * @brief numIslands
 * @param grid
 * @return the number of islands
 * Starting from (0, 0), find each island and tag it.
 *
 * T: O(N * M), S: O(N * M)
 */
int numIslands_sol1(vector&lt; vector&lt;char&gt; &gt;&amp; grid) {
    vector&lt; vector&lt;bool&gt; &gt; isTagged(
                grid.size(),
                vector&lt;bool&gt;(grid[0].size(), false));
    int numOfIslands = 0;

    // TODO: traverse grid
    for (int i = 0; i &lt; grid.size(); i++) {
        for (int j = 0; j &lt; grid[0].size(); j++) {
            if ((grid[i][j] == &apos;1&apos;) &amp;&amp; (!isTagged[i][j])) {
                numOfIslands++;
                // TODO: tag points within the island
                tagIsland(grid, isTagged, i, j);
            }
        }
    }

    return numOfIslands;
}</code></pre>

</section>
<section	id="numberofprovinces">
<h3>Number of Provinces</h3>

<blockquote>
<p>There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. </p>

<p>A province is a group of directly or indirectly connected cities and no other cities outside of the group. </p>

<p>You are given an n x n matrix isConnected where <code>isConnected[i][j] = 1</code> if the ith city and the jth city are directly connected, and <code>isConnected[i][j] = 0</code> otherwise. </p>

<p>Return the total number of provinces.</p>
</blockquote>

<p>Basic idea: traverse all cities. </p>

<ul>
<li>if the city is tagged with a province, then skip.</li>
<li>else find all cities which belongs to the same province as current city.</li>
</ul>
<pre><code class="cpp">/**
 * @brief tagCity
 * @param isConnected: connection map
 * @param isTagged: if current city is tagged
 * @param i: ith city
 */
void tagCity(vector&lt; vector&lt;int&gt; &gt;&amp; isConnected, vector&lt;bool&gt;&amp; isTagged, int i) {
    queue&lt;int&gt; q;
    q.push(i);
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        isTagged[cur] = true;
        for (int i = 0; i &lt; isConnected.size(); i++) {
            if ((i != cur) &amp;&amp; (!isTagged[i]) &amp;&amp; (isConnected[cur][i] == 1)) {
                q.push(i);
            }
        }
    }
}

/**
 * @brief findCircleNum_sol1
 * @param isConnected: a connection map where isConnected[i][j] = 1 if the ith city
 * and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.
 * @return the number of provinces
 *
 * Input: [ [1,1,0],
 *          [1,1,0],
 *          [0,0,1] ]
 *
 * Basic idea: traverse all cities.
 *  if the city is tagged with a province, then skip.
 *  else find all cities which belongs to the same province as current city.
 *
 * How to find directly or indirectly connected cities? isConnected map!
 *
 * T: O(N), S: O(N)
 */
int findCircleNum_sol1(vector&lt; vector&lt;int&gt; &gt;&amp; isConnected) {
    vector&lt;bool&gt; isTagged(isConnected.size(), false);
    int numOfProvinces = 0;

    // TODO: traverse all cities
    for (int i = 0; i &lt; isConnected.size(); i++) {
        if (!isTagged[i]) {
            numOfProvinces++;
            tagCity(isConnected, isTagged, i);
        }
    }

    return numOfProvinces;
}</code></pre>

</section>
<section	id="subtreeofanothertree">
<h3>Subtree of Another Tree</h3>

<blockquote>
<p>Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. </p>

<p>A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node&#8217;s descendants. The tree tree could also be considered as a subtree of itself.</p>
</blockquote>

<p>How to check if two trees are same? Recursion!</p>
<pre><code class="cpp">bool isEqual(TreeNode* lhs, TreeNode* rhs) {
    if ((lhs == nullptr) &amp;&amp; (rhs == nullptr)) {
        return true;
    }
    // either of them is nullptr then return false
    if ((lhs == nullptr) || (rhs == nullptr)) return false;

    if (lhs-&gt;val != rhs-&gt;val) return false;
    return (isEqual(lhs-&gt;left, rhs-&gt;left) &amp;&amp; isEqual(lhs-&gt;right, rhs-&gt;right));
}

/**
 * @brief isSubtree
 * @param root: the root of original tree
 * @param subRoot: sample subtree
 * @return true if root tree includes subRoot tree
 */
bool isSubtree(TreeNode* root, TreeNode* subRoot) {
    if (subRoot == nullptr) return true;
    if (root == nullptr) return false;

    if (isEqual(root, subRoot)) return true;

    return isSubtree(root-&gt;left, subRoot) || isSubtree(root-&gt;right, subRoot);
}</code></pre>

</section>
<section	id="populatingpointers">
<h3>Populating Pointers</h3>

<blockquote>
<p>Given a binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. </p>

<p>Initially, all next pointers are set to NULL.</p>
</blockquote>

<p>Notice that different from the similar question in Algorithm I, this is NOT a complete tree. But we are able to solve it with level-order search as well.</p>
<pre><code class="cpp">/**
 * @brief connect
 * @param root: the root of tree
 * @return a tree has been connected
 * Add new property &apos;level&apos; to each node. Traverse node in level order and connect
 * them.
 */
Node* connect(Node* root) {
    class QueueNode {
    public:
        QueueNode(int _level, Node* _node)
            : node(_node), level(_level) {}

        Node* node;
        int level;
    };

    if (root == nullptr) return root;
    QueueNode first(0, root);
    queue&lt;QueueNode&gt; que;
    que.push(first);
    while (!que.empty()) {
        QueueNode cur = que.front();
        que.pop();
        if (!que.empty()) {
            QueueNode next = que.front();
            if (cur.level == next.level) {
                cur.node-&gt;next = next.node;
            }
        }
        if (cur.node-&gt;left != nullptr) {
            que.push(QueueNode(cur.level+1, cur.node-&gt;left));
        }
        if (cur.node-&gt;right != nullptr) {
            que.push(QueueNode(cur.level+1, cur.node-&gt;right));
        }
    }

    return root;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>track level of each node.</li>
</ul>

</section>
<section	id="shortestpathinbinarymatrix">
<h3>Shortest Path in Binary Matrix</h3>

<blockquote>
<p>Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return &#8211;1. </p>

<p>A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:</p>
</blockquote>

<ul>
<li>All the visited cells of the path are 0.</li>
<li>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</li>
</ul>

<blockquote>
<p>The length of a clear path is the number of visited cells of this path.</p>
</blockquote>

<p>The algorithm is use point whose shortest path is known to render its neighboring points, tracking the shortest path for each point.</p>
<pre><code class="cpp">int shortestPathBinaryMatrix_sol3(vector&lt; vector&lt;int&gt; &gt;&amp; grid) {
    if (grid.size() == 0) return -1;
    if (grid[0][0] == 1) return -1;

    int target_x = grid.size() - 1;
    int target_y = grid[0].size() - 1;
    int x_direction[8] = {1, 0, 1, -1, 1, -1, 0, -1};
    int y_direction[8] = {1, 1, 0, 1, -1, 0, -1, -1};

    class Point {
    public:
        int x;
        int y;

        Point()
            : x(0), y(0) {};
        Point(int _x, int _y)
            : x(_x), y(_y) {};
    };

    vector&lt; vector&lt;int&gt; &gt; dist(grid.size(),
                               vector&lt;int&gt;(grid[0].size(), INT_MAX));
    dist[0][0] = 1;
    queue&lt;Point&gt; que;
    que.push(Point(0, 0));

    while (!que.empty()) {
        Point cur = que.front();
        que.pop();

        for (int i = 0; i &lt; 8; i++) {
            int x = cur.x + x_direction[i];
            int y = cur.y + y_direction[i];
            if ((x &gt;= 0) &amp;&amp; (y &gt;= 0)
                &amp;&amp; (x &lt; grid.size()) &amp;&amp; (y &lt; grid[0].size())
                &amp;&amp; (grid[x][y] == 0)
                &amp;&amp; (dist[x][y] == INT_MAX)) {
                dist[x][y] = dist[cur.x][cur.y] + 1;
                que.push(Point(x, y));
            }
        }
    }

    return (dist[target_x][target_y] == INT_MAX) ? -1 : dist[target_x][target_y];
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Tracking shortest path for each point.</li>
</ul>

</section>
<section	id="surroundedregions">
<h3>Surrounded Regions</h3>

<blockquote>
<p>Given an m x n matrix board containing &#8216;X&#8217; and &#8216;O&#8217;, capture all regions that are 4-directionally surrounded by &#8216;X&#8217;. </p>

<p>A region is captured by flipping all &#8217;O&#8217;s into &#8217;X&#8217;s in that surrounded region.</p>
</blockquote>

<p>We will concentrate on cells remain to be &#8216;O&#8217;, meaning will not be captured. Those cells are connected to the cells on the border. So we start from all border cells and BFS. At last, re-render our board with <code>buff</code>.</p>
<pre><code class="cpp">class Point {
public:
    int x;
    int y;
    Point(int _x, int _y)
        : x(_x), y(_y) {};
};

void traverseHelper(vector&lt; vector&lt;char&gt; &gt;&amp; board,
                    vector&lt; vector&lt;bool&gt; &gt;&amp; visited,
                    vector&lt;Point&gt;&amp; buf,
                    int ox, int oy) {
    int dir_x[4] = {-1, +1, 0, 0};
    int dir_y[4] = {0, 0, -1, +1};

    visited[ox][oy] = true;

    queue&lt;Point&gt; que;
    que.push(Point(ox, oy));
    buf.push_back(Point(ox, oy));
    while (!que.empty()) {
        Point cur = que.front();
        que.pop();
        for (int index = 0; index &lt; 4; index++) {
            int x = cur.x + dir_x[index];
            int y = cur.y + dir_y[index];
            if ((x &gt;= 0) &amp;&amp; (y &gt;= 0) &amp;&amp; (x &lt; board.size()) &amp;&amp; (y &lt; board[0].size())
                &amp;&amp; (board[x][y] == &apos;O&apos;)
                &amp;&amp; (!visited[x][y])) {
                visited[x][y] = true;
                que.push(Point(x, y));
                buf.push_back(Point(x, y));
            }
        }
    }
}

/**
 * @brief solve_sol2
 * @param board
 * On the contrary to sol1, we will concentrate on cells remain to be &apos;O&apos;, meaning
 * will not be captured. Those cells are connected to the cells on the border.
 *
 * So what we need to do is find all islands connected to the border.
 * - starting from all border cells and BFS
 */
void solve_sol2(vector&lt; vector&lt;char&gt; &gt;&amp; board) {
    if (board.size() == 0) return;
    vector&lt; vector&lt;bool&gt; &gt; visited(board.size(),
                                   vector&lt;bool&gt;(board[0].size(), false))

    // keep track all cells on islands connected with borders.
    vector&lt;Point&gt; buff;
    // left and right border
    for (int i = 0; i &lt; board.size(); i++) {
        if ((board[i][0] == &apos;O&apos;) &amp;&amp; (!visited[i][0])) {
            traverseHelper(board, visited, buff, i, 0);
        }
        if ((board[i][board[0].size()-1] == &apos;O&apos;) &amp;&amp; (!visited[i][board[0].size()-1])) {
            traverseHelper(board, visited, buff, i, board[0].size()-1);
        }
    }
    // top and bottom border
    for (int j = 0; j &lt; board[0].size(); j++) {
        if ((board[0][j] == &apos;O&apos;) &amp;&amp; (!visited[0][j])) {
            traverseHelper(board, visited, buff, 0, j);
        }
        if ((board[board.size()-1][j] == &apos;O&apos;) &amp;&amp; (!visited[board.size()-1][j])) {
            traverseHelper(board, visited, buff, 0, board.size()-1);
        }
    }

    // re-render board
    for (int i = 0; i &lt; board.size() - 1; i++) {
        for (int j = 0; j &lt; board[0].size() - 1; j++) {
            board[i][j] = &apos;X&apos;;
        }
    }
    for (Point pt : buff) {
        board[pt.x][pt.y] = &apos;O&apos;;
    }
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Find characteristics of result cells.</li>
</ul>

</section>
<section	id="allpathsfromsourcetotarget">
<h3>All Paths from Source to Target</h3>

<blockquote>
<p>Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order. </p>

<p>The graph is given as follows: <code>graph[i]</code> is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node <code>graph[i][j]</code>).</p>
</blockquote>

<p>Basically there are two ways: BFS or DFS with path tracking.</p>

<ul>
<li>BFS solution:</li>
</ul>
<pre><code class="cpp">/**
 * @brief allPathsSourceTarget_sol1
 * @param graph
 * @return all paths
 * Basically, BFS or DFS with tracking path.
 */
vector&lt; vector&lt;int&gt; &gt; allPathsSourceTarget_sol1(vector&lt; vector&lt;int&gt; &gt;&amp; graph) {
    vector&lt; vector&lt;int&gt; &gt; result;
    if (graph.size() == 0) return result;

    class QueueNode {
    public:
        int node;
        vector&lt;int&gt; path;
        QueueNode(int _node, vector&lt;int&gt; _path)
            : node(_node), path(_path) {}
    };

    int target = graph.size() - 1;
    queue&lt;QueueNode&gt; que;
    que.push(QueueNode(0, {0}));
    while (!que.empty()) {
        QueueNode cur = que.front();
        que.pop();
        if (cur.node == target) {
            result.push_back(cur.path);
        }
        for (int neighbor = 0; neighbor &lt; graph[cur.node].size(); neighbor++) {
            // choose
            cur.path.push_back(graph[cur.node][neighbor]);
            que.push(QueueNode(graph[cur.node][neighbor], cur.path));
            // unchoose
            cur.path.pop_back();
        }
    }

    return result;
}</code></pre>

<ul>
<li>DFS solution:</li>
</ul>
<pre><code class="cpp">void searchHelper(vector&lt; vector&lt;int&gt; &gt;&amp; graph,
                  vector&lt; vector&lt;int&gt; &gt;&amp; result,
                  int node,
                  vector&lt;int&gt;&amp; path,
                  int target) {
    if (node == target) {
        result.push_back(path);
    }

    for (int i = 0; i &lt; graph[node].size(); i++) {
        // choose
        path.push_back(graph[node][i]);
        searchHelper(graph, result, graph[node][i], path, target);
        // unchoose
        path.pop_back();
    }
}

/**
 * @brief allPathsSourceTarget_sol2
 * @param graph
 * @return
 * Solution2 will employ deep first search.
 */
vector&lt;vector &lt;int&gt; &gt; allPathsSourceTarget_sol2(vector&lt; vector&lt;int&gt; &gt;&amp; graph) {
    vector&lt; vector&lt;int&gt; &gt; result;
    if (graph.size() == 0) return result;
    vector&lt;int&gt; path = {0};

    searchHelper(graph, result, 0, path, graph.size()-1);

    return result;
}</code></pre>

</section>
</section>
<section	id="recursionandbacktracking">
<h2>Recursion and Backtracking</h2>

<section	id="subsets">
<h3>Subsets</h3>

<blockquote>
<p>Given an integer array nums of unique elements, return all possible subsets (the power set). </p>

<p>The solution set must not contain duplicate subsets. Return the solution in any order.</p>
</blockquote>
<pre><code class="cpp">void subsetsHelper(vector&lt;int&gt;&amp; left, vector&lt;int&gt;&amp; sofar,
                   vector&lt; vector&lt;int&gt; &gt;&amp; result) {
    if (left.size() == 0) {
        result.push_back(sofar);
        return;
    }

    int cur = left.back();
    left.pop_back();
    // not choose the last number
    subsetsHelper(left, sofar, result);
    // choose the last number
    sofar.push_back(cur); // reuse sofar
    subsetsHelper(left, sofar, result);
    // restore environment
    sofar.pop_back();
    left.push_back(cur);
}

/**
 * @brief subsets
 * @param nums
 * @return all subsets of given nums
 * Choose and not choose.
 */
vector&lt; vector&lt;int&gt; &gt; subsets(vector&lt;int&gt;&amp; nums) {
    vector&lt; vector&lt;int&gt; &gt; result;
    if (nums.size() == 0) return result;

    vector&lt;int&gt; sofar;
    subsetsHelper(nums, sofar, result);

    return result;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Reuse buffers and keep environment unchanged.</li>
</ul>

</section>
<section	id="subsetsii">
<h3>Subsets II</h3>

<blockquote>
<p>Given an integer array nums that may contain duplicates, return all possible subsets (the power set). </p>

<p>The solution set must not contain duplicate subsets. Return the solution in any order.</p>
</blockquote>

<p>One way to generate all subsets is construction.</p>
<pre><code class="cpp">/**
 * ex&gt; input: {0, 1, 2}
 * - start from {}
 * - 1st (add 0): ({}) + {0}
 * - 2nd (add 1): ({}, {0}) + {1}, {0, 1}
 * - 3rd (add 2): ({}, {0}, {1}, {0, 1}) + {2}, {0, 2}, {1, 2}, {0, 1, 2}
 * - so we get all subsets {}, {0}, {1}, {0, 1}, {2}, {0, 2}, {1, 2}, {0, 1, 2}
 */</code></pre>

<p>How to solve duplicates? Refine construction process (input nums must be ordered).</p>
<pre><code class="cpp">/**
 * ex&gt; input: {0, 2, 1, 2, 2, 3} -&gt; ordered {0, 1, 2, 2, 2, 3}
 * - start from {}
 * - 1st (add 0): ({}) + {0}
 * - 2nd (add 1): ({}, {0}) + {1}, {0, 1}
 * - 3rd (add 2): ({}, {0}, {1}, {0, 1}) + {2}, {0, 2}, {1, 2}, {0, 1, 2}
 * - 4th (add 2): when add duplicated number, we just need add to subsets generated
 * by previous step.
 * ({}, {0}, {1}, {0, 1}, {2}, {0, 2}, {1, 2}, {0, 1, 2}) + {2, 2}, {0, 2, 2}, {1, 2, 2}, {0, 1, 2, 2}
 *                         |-------- previous --------|
 * - 5th (add 2): ...
 */</code></pre>

<p>So we need to track the starting index of subsets generated in previous step. The algorithm will be:</p>

<ul>
<li>If new number has been seen before, construct new subsets with subsets generated in previouse step.</li>
<li>Construct new subsets with all existed subsets otherwise.</li>
</ul>
<pre><code class="cpp">/**
 * @brief subsetsWithDup
 * @param nums
 * @return
 */
vector&lt; vector&lt;int&gt; &gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {
    set&lt;int&gt; seen;
    vector&lt; vector&lt;int&gt; &gt; result;
    result.push_back({});
    int start = 0;
    sort(nums.begin(), nums.end());
    for (int i = 0; i &lt; nums.size(); i++) {
        if (seen.find(nums[i]) != seen.end()) {
            // has been seen, add to previous subsets
            vector&lt; vector&lt;int&gt; &gt; add;
            for (int j = start; j &lt; result.size(); j++) {
                vector&lt;int&gt; subset = result[j];
                subset.push_back(nums[i]);
                add.push_back(subset);
            }
            start = result.size();
            // concatenate new subsets
            result.insert(result.end(), add.begin(), add.end());
        }
        else {
            // not seen, add to all subsets
            seen.insert(nums[i]);
            vector&lt; vector&lt;int&gt; &gt; add;
            for (int j = 0; j &lt; result.size(); j++) {
                vector&lt;int&gt; subset = result[j];
                subset.push_back(nums[i]);
                add.push_back(subset);
            }
            start = result.size();
            // concatenate new subsets
            result.insert(result.end(), add.begin(), add.end());
        }
    }

    return result;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>For <code>seen</code>, there are two ways to achieve that. The generic way is use <code>set</code>. The other is based on given contrains: the range of <code>nums[i]</code> is from &#8211;10 to 10. Therefore, we are able to use a vector to map the range.</li>
</ul>

</section>
<section	id="permutationii">
<h3>Permutation II</h3>

<blockquote>
<p>Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.</p>
</blockquote>

<p>The way to get rid of duplications is similar to Subsets II. At each step of constructing new permutations, get rid of duplicated choices.</p>
<pre><code class="cpp">void permutationHelper(vector&lt;int&gt;&amp; left, vector&lt;int&gt;&amp; selected,
                       vector&lt; vector&lt;int&gt; &gt;&amp; result) {
    if (left.size() == 0) {
        result.push_back(selected);
        return;
    }

    set&lt;int&gt; seen;
    // choose:
    int size = left.size();
    for (int i = 0; i &lt; size; i++) {
        if (seen.find(left[i]) == seen.end()) {
            // not found
            seen.insert(left[i]);
            int cur = left[i];
            left.erase(left.begin() + i);
            selected.push_back(cur);
            permutationHelper(left, selected, result);
            // restore
            selected.pop_back();
            left.insert(left.begin() + i, cur);
        }
        else {
            // ignore current number
            continue;
        }
    }
}

/**
 * @brief permuteUnique_sol1
 * @param nums
 * @return all unique permutations.
 * We will generate all permutations by construction. If we do not take uniqueness
 * into consideration, n numbers will generate n! permutations.
 * ex&gt; input {1, 1, 2}
 * 1st: (1 | 1 | 2) 3 choices
 * 2nd: (1 | 2) | (1 | 2) | (1 | 1) 2 choices
 * 3nd: ... 1 choice
 * How to get rid of duplications? In each round, ignore duplicated number.
 */
vector&lt; vector&lt;int&gt; &gt; permuteUnique_sol1(vector&lt;int&gt;&amp; nums) {
    vector&lt; vector&lt;int&gt; &gt; result;
    if (nums.size() == 0) return result;
    vector&lt;int&gt; selected;

    sort(nums.begin(), nums.end());
    permutationHelper(nums, selected, result);

    return result;
}


void permutationHelper2(vector&lt;int&gt;&amp; left, vector&lt;int&gt;&amp; selected,
                       vector&lt; vector&lt;int&gt; &gt;&amp; result) {
    if (left.size() == 0) {
        result.push_back(selected);
        return;
    }

    vector&lt;bool&gt; seen(21, false);
    int shift = 10; // -10 -&gt; index 0
    // choose:
    int size = left.size();
    for (int i = 0; i &lt; size; i++) {
        if (!seen[left[i] + shift]) {
            // not found
            seen[left[i] + shift] = true;
            int cur = left[i];
            left.erase(left.begin() + i);
            selected.push_back(cur);
            permutationHelper(left, selected, result);
            // restore
            selected.pop_back();
            left.insert(left.begin() + i, cur);
        }
        else {
            // ignore current number
            continue;
        }
    }
}</code></pre>

<p>Tricks:</p>

<ul>
<li><code>vector.erase(iter)</code>: remove ith item.</li>
<li><code>vector.insert(iter, item)</code>: insert item to ith index.</li>
</ul>

</section>
<section	id="combinationsum">
<h3>Combination Sum</h3>

<blockquote>
<p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. </p>

<p>The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. </p>

<p>It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p>
</blockquote>

<p>The key to this problem is how to remove duplication. In general, we will handle that by <code>set</code> or a mapping <code>vector</code>.</p>
<pre><code class="cpp">/**
 * @brief combinationSumHelper
 * @param candidates
 * @param selected
 * @param result
 * @param target
 * Base case:
 *  if target is equal to 0, then bingo.
 *  if there is no candidate and target is not 0, fail.
 * Recursion:
 *  reduce the problem.
 *
 * Remove duplications with set&lt;string&gt;, we will sort the result and compare.
 */
void combinationSumHelper(vector&lt;int&gt;&amp; candidates,
                          vector&lt;int&gt;&amp; selected,
                          set&lt; vector&lt;int&gt; &gt;&amp; seen,
                          vector&lt; vector&lt;int&gt; &gt;&amp; result,
                          int target) {
    if (target == 0) {
        // BUG: we cannot sort selected directly as it will affect pop_back() in higher
        // level.
        // ex&gt; {3, 2, 2}, pop_back() will pop 2.
        //     {2, 2, 3}, pop_back() will pop 3. which causes conflicts.
        vector&lt;int&gt; sorted = selected;
        sort(sorted.begin(), sorted.end());
        if (seen.find(sorted) == seen.end()) {
            seen.insert(sorted);
            result.push_back(sorted);
        }
        return;
    }
    if ((candidates.size() == 0) || (target &lt; 0)) {
        return;
    }

    for (int i = 0; i &lt; candidates.size(); i++) {
        int cur = candidates[i];
        selected.push_back(cur);
        combinationSumHelper(candidates, selected, seen, result, target - cur);
        selected.pop_back();
    }
}

/**
 * @brief combinationSum_sol1
 * @param candidates
 * @param target
 * @return
 * Reduce the problem until the target is 0.
 * ex&gt; input: {2, 3, 6, 7} target 7
 * reduce to: {2} + result of {2 ,3, 6, 7} target 5 (should be {2, 3} target 5, as
 * 6 and 7 are greater than 5)
 * ...
 * until target == 0.
 */
vector&lt; vector&lt;int&gt; &gt; combinationSum_sol1(vector&lt;int&gt;&amp; candidates, int target) {
    vector&lt; vector&lt;int&gt; &gt; result;
    vector&lt;int&gt; selected;
    set&lt; vector&lt;int&gt; &gt; seen;

    combinationSumHelper(candidates, selected, seen, result, target);

    return result;
}</code></pre>

<p>However, for combination problems, we are able to solve it cleverly. Notice that all solutions starting from the first elements will include all other elements. Therefore, we are able to ignore the first element when we get all solutions starting from the second element.</p>

<p>Solve in order.</p>
<pre><code class="bash"># 1st: starting from 2, candidates are {2, 3, 6, 7}
# 2nd: starting from 3, candidates are {3, 6, 7}
# 3rd: starting from 6, candidates are {6, 7}
# ...</code></pre>
<pre><code class="cpp">/**
 * @brief combinationSumHelper2
 * @param candidates
 * @param selected
 * @param result
 * @param target
 * @param start: start from ith candidates
 */
void combinationSumHelper2(vector&lt;int&gt;&amp; candidates,
                          vector&lt;int&gt;&amp; selected,
                          vector&lt; vector&lt;int&gt; &gt;&amp; result,
                          int target, int start) {
    if (target == 0) {
        vector&lt;int&gt; sorted = selected;
        sort(sorted.begin(), sorted.end());
        result.push_back(sorted);
        return;
    }
    if ((candidates.size() == 0) || (target &lt; 0)) {
        return;
    }

    for (int i = start; i &lt; candidates.size(); i++) {
        int cur = candidates[i];
        selected.push_back(cur);
        combinationSumHelper2(candidates, selected,  result, target - cur, i);
        selected.pop_back();
    }
}

/**
 * @brief combinationSum_sol2
 * @param candidates
 * @param target
 * @return
 * Is there a better way to solve duplications? sorting and select in order.
 * ex&gt; input {3, 4, 5}
 * in all solution starting with 3, it involves 4. So we don&apos;t have to consider 3 for
 * the solution starting with 4.
 */
vector&lt; vector&lt;int&gt; &gt; combinationSum_sol2(vector&lt;int&gt;&amp; candidates, int target) {
    vector&lt; vector&lt;int&gt; &gt; result;
    vector&lt;int&gt; selected;
    set&lt; vector&lt;int&gt; &gt; seen;

    combinationSumHelper2(candidates, selected, result, target, 0);

    return result;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Remove duplications in combination problem: select in order.</li>
</ul>

</section>
<section	id="combinationsumii">
<h3>Combination Sum II</h3>

<blockquote>
<p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. </p>

<p>Each number in candidates may only be used once in the combination. </p>

<p>Note: The solution set must not contain duplicate combinations.</p>
</blockquote>

<p>The difference for this problem from Combination is there are duplicated elements. How to get rid of duplicated elements? One way to solve it is grouping them. For example, if there are <code>n</code> 1&#8217;s, then when process 1, it will have <code>n+1</code> branches. Keep each group unique.</p>
<pre><code class="cpp">void combinationSum2Helper2(vector&lt;int&gt;&amp; candidates_group,
                            vector&lt;int&gt;&amp; selected,
                            vector&lt; vector&lt;int&gt; &gt;&amp; result,
                            int target,
                            int start) {
    // base case:
    if (target == 0) {
        result.push_back(selected);
        return;
    }
    if ((target &lt; 0) | (start &gt;= candidates_group.size())) {
        return;
    }

    // recursion:
    int cnt = candidates_group[start];
    int cur = start;
    int next_start = start + 1;
    while ((next_start &lt; candidates_group.size()) &amp;&amp; (candidates_group[next_start] == 0)) {
        next_start++;
    }

    // select 0 to cnt times
    for (int i = 0; i &lt;= cnt; i++) {
        for (int j = 0; j &lt; i; j++) {
            selected.push_back(cur);
        }
        combinationSum2Helper2(candidates_group, selected, result, target - cur * i, next_start);
        for (int j = 0; j &lt; i; j++) {
            selected.pop_back();
        }
    }
}

/**
 * @brief combinationSum2_sol2
 * @param candidates
 * @param target
 * @return
 * Two observations:
 * - In this problem, each number in the input is not unique. The implication of this
 * difference is that we need some mechanism to avoid generating duplicate combinations.
 * - In this problem, each number can be used only once. The implication of this difference
 * is that once a number is chosen as a candidate in the combination, it will not appear
 * again as a candidate later.
 * The key here is to keep all elements unique. Then is has the same solution to CombinationSum.
 *
 * One way to solve it is to group.
 * ex&gt; candidates: {1, 1, 1, 1, 3}   target = 3
 * We will see 4 1&apos;s as a group. Then there are two elements {1, 1, 1, 1} and 3.
 * 1st: {}(3) -&gt; {}(3) | {1}(2) | {1, 1}(1) | {1, 1, 1}(0) | {1, 1, 1, 1}(-1)
 * 2nd: choose 3 or not.
 *
 * in other word, if 1 is seen in previous candidates, then it can only be chosen. That is
 * the first 1 can be chosen and not, but the following 1&apos;s must be chosen.
 */
vector&lt; vector&lt;int&gt; &gt; combinationSum2_sol2(vector&lt;int&gt;&amp; candidates, int target) {
    vector&lt; vector&lt;int&gt; &gt; result;
    vector&lt;int&gt; selected;
    sort(candidates.begin(), candidates.end());

    // TODO: group, 1 &lt;= candidates[i] &lt;= 50
    vector&lt;int&gt; candidates_group(51, 0);
    for (int i = 0; i &lt; candidates.size(); i++) {
        candidates_group[candidates[i]]++;
    }

    combinationSum2Helper2(candidates_group, selected, result, target, candidates[0]);

    return result;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Group: one way to keep elements unique.</li>
</ul>

</section>
<section	id="lettercombinationsofphonenumber">
<h3>Letter Combinations Of Phone Number</h3>

<blockquote>
<p>Given a string containing digits from 2&#8211;9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. </p>

<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
</blockquote>

<p>This a a classic combination problem which can be solved with decision tree.</p>
<pre><code class="cpp">void letterCombinationsHelper(string&amp; left, string&amp; chosen,
                              vector&lt;string&gt;&amp; result,
                              unordered_map&lt;int, string&gt;&amp; map,
                              int index) {
    if (index &gt;= left.size()) {
        result.push_back(chosen);
        return;
    }

    char cur = left[index];
    for (char ch : map[cur - &apos;0&apos;]) {
        // choose
        chosen.push_back(ch);
        letterCombinationsHelper(left, chosen, result, map, index + 1);
        // unchoose
        chosen.pop_back();
    }
}

/**
 * @brief letterCombinations
 * @param digits
 * @return
 * Decision tree.
 */
vector&lt;string&gt; letterCombinations(string digits) {
    vector&lt;string&gt; result;
    if (digits.size() == 0) return result;

    unordered_map&lt;int, string&gt; map = {
        {2, &quot;abc&quot;}, {3, &quot;def&quot;}, {4, &quot;ghi&quot;},
        {5, &quot;jkl&quot;}, {6, &quot;mno&quot;}, {7, &quot;pqrs&quot;},
        {8, &quot;tuv&quot;}, {9, &quot;wxyz&quot;}
    };
    string chosen;
    letterCombinationsHelper(digits, chosen, result, map, 0);

    return result;
}</code></pre>

</section>
<section	id="generateparentheses">
<h3>Generate Parentheses</h3>

<blockquote>
<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
</blockquote>

<p>Group and make decisions. Two observations:</p>

<ul>
<li>left parentheses <code>(</code> is allowed to be chosen when it is available.</li>
<li>right parentheses <code>)</code> allowed when the number of right parentheses is greater than that of left parentheses.</li>
</ul>
<pre><code class="cpp">void generateParenthesisHelper(vector&lt;int&gt;&amp; left,
                               string chosen,
                               vector&lt;string&gt;&amp; result) {
    if (left[0] == 0) {
        // left parentheses has been run out of.
        for (int i = 0; i &lt; left[1]; i++) {
            chosen.push_back(&apos;)&apos;);
        }
        result.push_back(chosen);
        for (int i = 0; i &lt; left[1]; i++) {
            chosen.pop_back();
        }
        return;
    }

    // choose left or right?
    // - condition for left: if left is available
    // - condition for right: if # of right parentheses &gt; # of left parentheses
    // choose left
    chosen.push_back(&apos;(&apos;);
    left[0]--;
    generateParenthesisHelper(left, chosen, result);
    chosen.pop_back();
    left[0]++;

    // choose right
    if (left[1] &gt; left[0]) {
        chosen.push_back(&apos;)&apos;);
        left[1]--;
        generateParenthesisHelper(left, chosen, result);
        chosen.pop_back();
        left[1]++;
    }
}

/**
 * @brief generateParenthesis
 * @param n
 * @return combinations of all parentheses
 * It can be seen as group problem. We can create a vector to store how much left/right
 * parentheses left and make decisions on each step.
 *
 * T: O(N!)
 */
vector&lt;string&gt; generateParenthesis(int n) {
    vector&lt;string&gt; result;
    if (n == 0) return result;
    vector&lt;int&gt; left = {n, n};
    string chosen;
    generateParenthesisHelper(left, chosen, result);

    return result;
}</code></pre>

</section>
<section	id="wordsearch">
<h3>Word Search</h3>

<blockquote>
<p>Given an m x n grid of characters board and a string word, return true if word exists in the grid. </p>

<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
</blockquote>

<p>The solution to the problem is similar to maze with DFS.</p>
<pre><code class="cpp">bool existHelper(vector&lt; vector&lt;char&gt; &gt;&amp; board,
                 vector&lt; vector&lt;bool&gt; &gt;&amp; visited,
                 string&amp; word,
                 int x, int y,
                 int start) {
    static int dir_x[4] = {0, +1, 0, -1};
    static int dir_y[4] = {+1, 0, -1, 0};

    if (start &gt;= word.size()) {
        return true;
    }

    if ((x &lt; 0) || (x &gt;= board.size()) || (y &lt; 0) || (y &gt;= board[0].size())) {
        // out of bounds
        return false;
    }
    if (word[start] != board[x][y]) {
        // not equal
        return false;
    }
    if (visited[x][y]) {
        // cannot be chosen twice
        return false;
    }

    visited[x][y] = true;
    for (int i = 0; i &lt; 4; i++) {
        // search on 4 directions
        int next_x = x + dir_x[i];
        int next_y = y + dir_y[i];
        if (existHelper(board, visited, word, next_x, next_y, start+1)) {
            return true;
        }
    }
    visited[x][y] = false;

    return false;
}

/**
 * @brief exist
 * @param board
 * @param word
 * @return
 * The solution to the problem is similar to maze with DFS.
 */
bool exist(vector&lt; vector&lt;char&gt; &gt;&amp; board, string word) {
    int m = board.size();
    int n = board[0].size();
    if (word.size() == 0) return true;
    if (m == 0) return false;

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (board[i][j] == word[0]) {
                // keep one cell chosen one time
                vector&lt; vector&lt;bool&gt; &gt; visited(m, vector&lt;bool&gt;(n, false));
                // seed cell is found
                if (existHelper(board, visited, word, i, j, 0)) {
                    return true;
                }
            }
        }
    }

    return false;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Restore environment before backtracking.</li>
</ul>

</section>
</section>
<section	id="dynamicprogramming">
<h2>Dynamic Programming</h2>

<section	id="houserobberii">
<h3>House Robber II</h3>

<blockquote>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. </p>

<p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p>
</blockquote>

<p>The first solution is by recursion and buffer.</p>
<pre><code class="cpp">/**
 * @brief maxIncome
 * @param vals: a vector of money each house has
 * @param size: size of houses
 * @param start: start of available houses to rob
 * @param length: how many houses left to rob
 * @return
 */
int maxIncome(vector&lt; vector&lt; int &gt; &gt;&amp; buf,
              vector&lt;int&gt;&amp; vals, int size,
              int start, int length) {
    if (length &lt;= 0) {
        return 0;
    }

    if (buf[start][length] != -1) {
//        cout &lt;&lt; start &lt;&lt; &quot;: &quot; &lt;&lt; length &lt;&lt; &quot; =&gt; &quot; &lt;&lt; buf[start][length] &lt;&lt; endl;
        return buf[start][length];
    }

    buf[start][length] = max(vals[start] + maxIncome(buf, vals, size, (start + 2) % size, length - 2),
                             maxIncome(buf, vals, size, (start + 1) % size, length - 1)
                            );
//    cout &lt;&lt; start &lt;&lt; &quot;: &quot; &lt;&lt; length &lt;&lt; &quot; =&gt; &quot; &lt;&lt; buf[start][length] &lt;&lt; endl;

    return buf[start][length];
}

/**
 * @brief rob_sol1
 * @param nums
 * @return the maximum value of robbed money
 * Recall from algorithm for houserobber, and we can find there is some similarity betwee
 * these two problems. The only difference is there is a circle in houserobber2.
 *
 * But the circle only affects the decision for the first time.
 *
 * ex&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
 *     |-------&lt;-----------|
 *
 * If we have decided where to start, let&apos;s say 1.
 * then the problem will be:
 *
 * - choose 1 + max{ 3 -&gt; 4 }
 * - not choose 1 + max { 2 -&gt; 3 -&gt; 4 -&gt; 5 }
 *
 * it will become houserobber problem. And for the houserobber, the basic algorithm is
 *
 * f(start, length) = max(
 *     val[start] + f((start + 2) % size, length - 2),  // circle version
 *     f((start + 1) % size, length - 1)
 * )
 *
 * and base case occurs when length &lt; 0, return 0;
 */
int rob_sol1(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0) return 0;
    if (nums.size() == 1) return nums[0];
    int size = nums.size();
    vector&lt; vector&lt; int &gt; &gt; buf(
                size,
                vector&lt;int&gt;(size+1, -1));
    for (int i = 0; i &lt; size; i++) {
        buf[i][0] = 0;
    }

    int maxMoney = 0;
    // try all starting point
    for (int i = 0; i &lt; size; i++) {
        int bigger = max(nums[i] + maxIncome(buf, nums, size, (i + 2) % size, size-3), // i-1, i, i+1
                       maxIncome(buf, nums, size, (i + 1) % size, size-1)); // i
        if (bigger &gt; maxMoney) {
            maxMoney = bigger;
        }
    }

    return maxMoney;
}</code></pre>

<p>The second solution is from bottom to top by dynamic programming.</p>
<pre><code class="cpp">/**
 * @brief rob_sol2
 * @param nums
 * @return
 * According to the formula we derived from solution 1, we are able to solve the problem
 * from bottom to top. That&apos;s dynamic programming.
 *
 * f(start, length) = max(val[start] + f((start + 2) % size), length-2),
 *                        f((start + 1) % size), length-1)
 *                       )
 *
 * ex&gt; 2 -&gt; 3 -&gt; 2 -&gt; 3  (size: 4)
 *     |------&lt;-------|
 * buf:
 * start\length  0  1  2              3
 *   0           0  2  max(2 + 0, 3)  ...
 *   1           0  3  ...
 *   2           0  2
 *   3           0  3
 */
int rob_sol2(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0) return 0;
    if (nums.size() == 1) return nums[0];
    if (nums.size() == 2) return max(nums[0], nums[1]); // notice &apos;size-3&apos; in formula
    int size = nums.size();
    vector&lt; vector&lt; int &gt; &gt; buf(
                size,
                vector&lt;int&gt;(size+1, -1));
    for (int start = 0; start &lt; size; start++) {
        buf[start][0] = 0;
        buf[start][1] = nums[start];
    }

    // !!!: notice render order
    for (int length = 2; length &lt;= size; length++) {
        for (int start = 0; start &lt; size; start++) {
            buf[start][length] = max(nums[start] + buf[(start + 2) % size][length-2],
                                     buf[(start + 1) % size][length-1]);
//            cout &lt;&lt; start &lt;&lt; &quot;: &quot; &lt;&lt; length &lt;&lt; &quot; =&gt; &quot; &lt;&lt; buf[start][length] &lt;&lt; endl;
        }
    }

    int maxMoney = 0;
    // try all starting point
    for (int i = 0; i &lt; size; i++) {
        int bigger = max(nums[i] + buf[(i + 2) % size][size-3], // i-1, i, i+1
                       buf[(i + 1) % size][size-1]); // i
        if (bigger &gt; maxMoney) {
            maxMoney = bigger;
        }
    }

    return maxMoney;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Start from divide and conquer and derive formula.</li>
<li>Be careful for the order when solving from bottom to top.</li>
</ul>

</section>
<section	id="jumpgame">
<h3>Jump Game</h3>

<blockquote>
<p>You are given an integer array nums. You are initially positioned at the array&#8217;s first index, and each element in the array represents your maximum jump length at that position. </p>

<p>Return true if you can reach the last index, or false otherwise.</p>
</blockquote>

<p>Start from divide and conquer. </p>
<pre><code class="bash"># ex&gt; 2, 3, 1, 1, 4
#  i: 0  1  2  3  4
# start from index 0: jump choice 1 ~ val[0]
# =&gt;: 1 + jump in {3, 1, 1, 4}
#     2 + jump in {1, 1, 4}
#     ...
#
# define f as f(index)
# f(index) = true means I can jump to the end from index, f(index) = false otherwise.</code></pre>
<pre><code class="cpp">/**
 * @brief canJump_sol3
 * @param nums
 * @return
 * In fact, we can refine function to have only one parameter.
 * f(index) = true means I can jump to the end from index, f(index) = false otherwise.
 *
 * ex&gt; 2, 3, 1, 1, 4
 *  i: 0  1  2  3  4
 *
 * In dynamic programming, we start from the last one.
 * f(4) = true;
 * f(3) = f(3+1) | f(3+2) | ... | f(3+maximum)
 * ...
 *
 * T: O(N^2)
 */
bool canJump_sol3(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0)  return false;
    if (nums.size() == 1)  return true;
    int size = nums.size();
    vector&lt;bool&gt; buf(size, false);
    int target_index = size - 1;
    for (int i = size - 1; i &gt;= 0; i--) {
        if (i == target_index) {
            buf[i] = true;
        }
        else {
            for (int jump = 1; jump &lt;= nums[i]; jump++) {
                if (buf[i+jump] == true) {
                    buf[i] = true;
                    break;
                }
            }
        }
    }

    return buf[0];
}
</code></pre>

<p>Tricks:</p>

<ul>
<li>Simplify the defination of <code>buf</code> and grasp core information.</li>
</ul>

</section>
<section	id="jumpgameii">
<h3>Jump Game II</h3>

<blockquote>
<p>Given an array of non-negative integers nums, you are initially positioned at the first index of the array. </p>

<p>Each element in the array represents your maximum jump length at that position. </p>

<p>Your goal is to reach the last index in the minimum number of jumps. </p>

<p>You can assume that you can always reach the last index.</p>
</blockquote>

<p>We provide two solutions to this problem: dynamic programming and greedy.</p>

<ul>
<li>Dynamic Programming Solution</li>
</ul>

<p>But think of shortest path problem. The key idea is to find the shortest jumps by making locally optimal choices at each index which leads to a globally optimal solution. We are able to define <code>f</code> as:</p>

<p>f(index): the shortest step from start to index.</p>

<p>f(index) = min(f(directly connected indices) + 1), where directly connected means indices where I can jump to current index with one jump.</p>
<pre><code class="cpp">/**
 * @brief jump_sol1
 * @param nums
 * @return
 * From the solution for jump I, we can enumerate all solutions to the last index and find
 * the one with the least steps.
 *
 * T: O(N^2 * M), where M is maximum length one can jump from an index.
 *
 * But think of shortest path problem. The key idea is to find the shortest jumps by making
 * locally optimal choices at each index which leads to a globally optimal solution. We are
 * able to define f as:
 *
 * f(index): the shortest step from start to index.
 *
 * ex&gt; 2, 3, 1, 1, 4
 *  i: 0  1  2  3  4
 *
 * f(index) = min(f(directly connected indices) + 1);
 * directly connected means indices where I can jump to current index with one jump.
 *
 * T: O(N^2)
 */
int jump_sol1(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0) return 0;
    int size = nums.size();
    vector&lt;int&gt; shortest_steps(size, INT_MAX);
    shortest_steps[0] = 0;

    for (int cur = 1; cur &lt; size; cur++) {
        int shortest = INT_MAX;
        for (int pre = cur-1; pre &gt;= 0; pre--) {
            // find all directed connected indices and update shortest_steps[cur]
            if (pre + nums[pre] &gt;= cur) {
                if (shortest_steps[pre] + 1 &lt; shortest) {
                    shortest = shortest_steps[pre] + 1;
                }
            }
        }
        shortest_steps[cur] = shortest;
    }

    return shortest_steps[nums.size()-1];
}</code></pre>

<ul>
<li>Greedy Algorithm</li>
</ul>
<pre><code class="cpp">/**
 * @brief jump_sol2
 * @param nums
 * @return
 * Solution 2 will introduce greedy algorithm. What we are concerned about is which place
 * is able to take me furthest?
 *
 * ex&gt; ... 3, 5, 2, 1, 4, 1, 6, 2, ...
 *         ^  |-----|
 *        cur   jump
 *
 * There are three choices (jump to 5, 2, 1) but where to go?
 * The greedy algorithm tells us to choose the one take me farthest, given that &apos;end&apos; is
 * not within the range where current jump can reach. Consider the next jump:
 *
 * - if I jump to 5, I can jump to as farthest as 6 with 2 steps (one current and one next).
 *
 *    ... 3, 5, 2, 1, 4, 1, 6, 2, ...
 *        ^  ^              ^
 *       cur next        farthest
 *
 * - if I jump to 1, I can jump to as farthest as 4 with 2 steps
 *
 *    ... 3, 5, 2, 1, 4, 1, 6, 2, ...
 *        ^        ^  ^
 *       cur      next farthest
 *
 * Therefore, I will choose to jump to 5 for current jump decision.
 *
 * T: O(N)
 */
int jump_sol2(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0) return 0;
    int size = nums.size();
    int cur = 0;
    int target = size - 1;
    // the right end of the range where current jump can reach
    int next_end = cur + nums[cur];
    int jump = 0;
    while (next_end &lt; target) {
        int farthest = 0;
        int best_next = 0;
        for (int next = cur + 1; next &lt;= cur + nums[cur]; next++) {
            // jump range
            if ((next + nums[next]) &gt; farthest) {
                farthest = next + nums[next];
                best_next = next;
            }
        }
        cur = best_next;
        next_end = farthest;
        jump++;
    }

    // last jump
    if (cur &lt; target) jump++;

    return jump;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Make locally optimal choices at each step which leads to a globally optimal solution</li>
</ul>

</section>
<section	id="uniquepath">
<h3>Unique Path</h3>

<blockquote>
<p>There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., <code>grid[0][0]</code>). The robot tries to move to the bottom-right corner (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time. </p>

<p>Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. </p>

<p>The test cases are generated so that the answer will be less than or equal to 2 * 10<sup>9</sup>.</p>
</blockquote>

<p>Define <code>unique_path[m][n]</code> as the number of unique path to (m&#8211;1, n&#8211;1), then <code>unique[i][j] = unique[i-1][j] (up) + unique[i][j-1] (left)</code>.</p>
<pre><code class="cpp">/**
 * @brief uniquePaths
 * @param m
 * @param n
 * @return
 * Solution 1 is to solve from easy case to complex one.
 *
 * ex&gt; m = 2, n = 3
 *
 * define unique_path[m][n] as the number of unique path to (m-1, n-1).
 * unique[0][0] = 0 ==&gt; unique[m-1][n-1]?
 *
 * unique[i][j] = unique[i-1][j] (up) + unique[i][j-1] (left);
 *
 * T: O(M * N)
 */
int uniquePaths(int m, int n) {
    if ((m == 0) || (n == 0)) return 0;
    vector&lt; vector&lt;int&gt; &gt; unique_path(m, vector&lt;int&gt;(n, 0));
    for (int row = 0; row &lt; m; row++) {
        unique_path[row][0] = 1;
    }
    for (int col = 0; col &lt; n; col++) {
        unique_path[0][col] = 1;
    }

    for (int row = 1; row &lt; m; row++) {
        for (int col = 1; col &lt; n; col++) {
            if ((row - 1) &gt;= 0) {
                unique_path[row][col] += unique_path[row-1][col];
            }
            if ((col - 1) &gt;= 0) {
                unique_path[row][col] += unique_path[row][col-1];
            }
        }
    }

    return unique_path[m-1][n-1];
}

/* ****************************** *
 *          UNIT TEST
 * ****************************** */
PROVIDED_TEST(&quot;test for sol1:&quot;) {
    EXPECT_EQUAL(uniquePaths(3, 7), 28);
    EXPECT_EQUAL(uniquePaths(3, 2), 3);
}</code></pre>

</section>
<section	id="jumpgameiii">
<h3>Jump Game III</h3>

<blockquote>
<p>Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to <code>i + arr[i]</code> or <code>i - arr[i]</code>, check if you can reach to any index with value 0. </p>

<p>Notice that you can not jump outside of the array at any time.</p>
</blockquote>

<p>The linear search can be transformed as graph search. Therefore, BFS or DFS.</p>
<pre><code class="cpp">/**
 * @brief canReach_sol2
 * @param arr
 * @param start
 * @return
 * Change linear structure of arr to a graph, then DFS or BFS!
 */
bool canReach_sol2(vector&lt;int&gt;&amp; arr, int start) {
    if (arr.size() == 0) return false;
    int size =  arr.size();

    vector&lt;bool&gt; visited(size, false);

    // TODO: start from &apos;start&apos; with BFS
    queue&lt;int&gt; que;
    que.push(start);
    while (!que.empty()) {
        int cur = que.front();
        que.pop();
        visited[cur] = true;

        if (arr[cur] == 0) {
            return true;
        }

        if ((cur - arr[cur] &gt;= 0) &amp;&amp; (!visited[cur - arr[cur]])) {
            que.push(cur - arr[cur]);
        }
        if ((cur + arr[cur] &lt; size) &amp;&amp; (!visited[cur + arr[cur]])) {
            que.push(cur + arr[cur]);
        }
    }

    return false;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Data representation is VERY important in depending algorithm.</li>
</ul>

</section>
<section	id="jumpgameiv">
<h3>Jump Game IV</h3>

<blockquote>
<p>Given an array of integers arr, you are initially positioned at the first index of the array. </p>

<p>In one step you can jump from index i to index:<br/>
1. i + 1 where: i + 1 &lt; arr.length.<br/>
2. i - 1 where: i - 1 &gt;= 0.<br/>
3. j where: arr[i] == arr[j] and i != j. </p>

<p>Return the minimum number of steps to reach the last index of the array. </p>

<p>Notice that you can not jump outside of the array at any time.</p>
</blockquote>

<p>The problem is similar to jump game III. To find the minimum steps, BFS is the solution.</p>
<pre><code class="cpp">int minJumps(vector&lt;int&gt;&amp; arr) {
    if (arr.size() == 0) return 0;
    int size = arr.size();
    int target = size - 1;
    vector&lt;bool&gt; visited(size, false);

    class QueueNode {
    public:
        int index;
        int step;
        QueueNode(int _index, int _step)
            : index(_index), step(_step) {}
    };
    queue&lt;QueueNode&gt; que;
    que.push(QueueNode(0, 0));
    visited[0] = true;

    // cluster[val] -&gt; {index with val == &apos;val&apos;}
    unordered_map&lt;int, vector&lt;int&gt; &gt; cluster;
    for (int i = 0; i &lt; size; i++) {
           cluster[arr[i]].push_back(i);
    }

    while (!que.empty()) {
        QueueNode cur = que.front();
        que.pop();


        if (cur.index == target) {
            return cur.step;
        }

        if ((cur.index - 1 &gt;= 0) &amp;&amp; (!visited[cur.index-1])) {
            que.push(QueueNode(cur.index-1, cur.step+1));
            visited[cur.index-1] = true;
        }
        if ((cur.index + 1 &lt; size) &amp;&amp; (!visited[cur.index+1])) {
            que.push(QueueNode(cur.index+1, cur.step+1));
            visited[cur.index+1] = true;
        }

        // all brothers and sisters in cluster
        vector&lt;int&gt; brothers = cluster[arr[cur.index]];
        for (int i = 0; i &lt; brothers.size(); i++) {
            if ((brothers[i] != cur.index) &amp;&amp; (!visited[brothers[i]])){
                que.push(QueueNode(brothers[i], cur.step+1));
                visited[brothers[i]] = true;
            }
        }
    }

    return -1;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>To avoid traverse circly, use <code>visited</code> to record visited node.</li>
</ul>

</section>
<section	id="longestpalindromesubstring">
<h3>Longest Palindrome Substring</h3>

<blockquote>
<p>Given a string s, return the longest palindromic substring in s.</p>
</blockquote>

<p>Dynamic programming solution is shown as follows.</p>
<pre><code class="cpp">/**
 * @brief longestPalindrome
 * @param s
 * @return
 * Work it out in dynamic programming way. Define f as:
 *
 * f(left, right): true if string[left...right] is palindrome.
 *
 * f(left, right) has three cases:
 * 1. left == right, true (base case)
 * 2. right - left == 1, meaning substrings with two letters
 *    f(left, right) = s[left] == s[right], ex&gt; &apos;aa&apos; (true) &apos;bc&apos; (false)
 * 3. right - left &gt; 1, meanning the length of substring is greater than 2.
 *    f(left, right) = f(left+1, right-1) &amp; s[left] == s[right]
 *
 * Derivation direction can be figured out from f(left, right) = f(left+1, right-1).
 *
 * T: O(N^2)
 */
string longestPalindrome(string s) {
    if (s.length() == 0) return &quot;&quot;;
    int size = s.length();
    vector&lt; vector&lt;bool&gt; &gt; isPalindrome(size, vector&lt;bool&gt;(size, false));

    int longest = 1;
    string result;
    result.push_back(s[0]);

    // case 1: single character
    for (int i = 0; i &lt; size; i++) {
        isPalindrome[i][i] = true;
    }

    // case 2: substring with size of 2
    for (int left = 0; left &lt; size; left++) {
        if (s[left] == s[left+1]) {
            isPalindrome[left][left+1] = true;
            // update longest
            longest = 2;
            result = s.substr(left, 2);
        }
    }

    // case 3: length is greater than 2
    // outter: from left to right
    // inner: from top to bottom
    for (int right = 2; right &lt; size; right++) {
        for (int left = 0; left &lt;= right - 2; left++) {
            if ((isPalindrome[left+1][right-1]) &amp;&amp; (s[left] == s[right])) {
                isPalindrome[left][right] = true;
                // update longest
                if ((right - left + 1) &gt; longest) {
                    longest = right - left + 1;
                    result = s.substr(left, longest);
                }
            }
        }
    }

    return result;
}</code></pre>

</section>
<section	id="arithmeticslices">
<h3>Arithmetic Slices</h3>

<blockquote>
<p>An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. </p>

<p>For example, <code>[1,3,5,7,9]</code>, <code>[7,7,7,7]</code>, and <code>[3,-1,-5,-9]</code> are arithmetic sequences. </p>

<p>Given an integer array nums, return the number of arithmetic subarrays of nums. </p>

<p>A subarray is a contiguous subsequence of the array.</p>
</blockquote>

<ul>
<li>Dynamic Programming Solution</li>
</ul>
<pre><code class="cpp">/**
 * @brief numberOfArithmeticSlices
 * @param nums
 * @return
 * Again, dynamic programming. We define f as:
 *
 * f(left, right): true if right - left &gt;= 2 and nums[left, right] is arithmetic.
 *
 * f(left, right) has two cases:
 * 1. base case: f(left, left+2)
 * 2. derive case: f(left, right) = f(left, right-1) &amp;
 *                 (nums[right] - nums[right-1]) == (nums[left+1] - nums[left])
 *
 * Derivation direction can be figured out from f(left, right) = f(left, right-1).
 *
 * T: O(N^2)
 */
int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) {
    if (nums.size() &lt; 3) return 0;
    int size = nums.size();
    int cnt = 0;
    vector&lt; vector&lt;bool&gt; &gt; isSlice(size, vector&lt;bool&gt;(size, false));

    // case 1:
    for (int i = 0; i &lt; (size - 2); i++) {
        if ((nums[i+2] - nums[i+1]) == (nums[i+1] - nums[i])) {
            isSlice[i][i+2] = true;
            cnt++;
        }
    }

    // case 2:
    for (int right = 3; right &lt; size; right++) {
        for (int left = 0; left &lt;= right - 3; left++) {
            if ((isSlice[left][right-1]) &amp;&amp;
                ((nums[right] - nums[right-1]) == (nums[left+1] - nums[left]))) {
                isSlice[left][right] = true;
                cnt++;
            }
        }
    }

    return cnt;
}</code></pre>

</section>
<section	id="decodeways">
<h3>Decode Ways</h3>

<blockquote>
<p>A message containing letters from A-Z can be encoded into numbers using the following mapping: </p>

<p>&#8216;A&#8217; -&gt; &#8220;1&#8221;, &#8216;B&#8217; -&gt; &#8220;2&#8221;, &#8230;, &#8216;Z&#8217; -&gt; &#8220;26&#8221; </p>

<p>To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &#8220;11106&#8221; can be mapped into: </p>

<p>&#8220;AAJF&#8221; with the grouping (1 1 10 6)<br/>
&#8220;KJF&#8221; with the grouping (11 10 6) </p>

<p>Given a string s containing only digits, return the number of ways to decode it.</p>
</blockquote>

<ul>
<li>Recursion Solution:</li>
</ul>
<pre><code class="cpp">int numDecodeHelper(string&amp; s, unordered_map&lt;string, char&gt;&amp; map, int start) {
    if (start &gt;= s.length()) {
        return 1;
    }
    if (start == s.length()-1) {
        string key = string(1, s[start]);
        if ((map[key] &lt;= &apos;Z&apos;) &amp;&amp; (map[key] &gt;= &apos;A&apos;)) {
            return 1;
        }
    }

    int num= 0;
    string key = string(1, s[start]);
    if ((map[key] &lt;= &apos;Z&apos;) &amp;&amp; (map[key] &gt;= &apos;A&apos;)) {
        num += numDecodeHelper(s, map, start+1);
    }

    key.push_back(s[start+1]);
    if ((map[key] &lt;= &apos;Z&apos;) &amp;&amp; (map[key] &gt;= &apos;A&apos;))  {
        num += numDecodeHelper(s, map, start+2);
    }

    return num;
}

/**
 * @brief numDecodings_sol1
 * @param s
 * @return
 * The first idea is to solve it by recursion.
 *
 * ex&gt; code = &apos;11106&apos;
 * numDecoding(code) = numDecoding(code.substr(1)) + numDecoding(code.substr(2)) if
 * code[0-1] is a valid mapped character.
 *
 * T: O(2^N)
 */
int numDecodings_sol1(string s) {
    if (s.size() == 0) return 0;
    // TODO: construct map
    unordered_map&lt;string, char&gt; map;
    for (int i = 0; i &lt; 26; i++) {
        map[to_string(i+1)] = &apos;A&apos; + i;
    }

    int result = numDecodeHelper(s, map, 0);

    return result;
}</code></pre>

<ul>
<li>Dynamic Programming</li>
</ul>
<pre><code class="cpp">/**
 * @brief numDecodings_sol2
 * @param s
 * @return
 * To avoid repeated calculation, dynamic programming comes into play. Define f as:
 *
 * f(index) is the number of decodings starting from index.
 *
 * Derivation: f(index) = f(index+1) if s[index] is valid
 *                        + f(index+2) if s[index...index+1] is valid
 *
 * Base case: if index &gt; s.size()-1, f(index) = 1;
 *
 * T: O(N)
 */
int numDecodings_sol2(string s) {
    if (s.size() == 0) return 0;
    int size = s.size();

    // TODO: construct map
    unordered_map&lt;string, char&gt; map;
    for (int i = 0; i &lt; 26; i++) {
        map[to_string(i+1)] = &apos;A&apos; + i;
    }

    vector&lt;int&gt; f(size + 1, 0);
    f[size] = 1;
    if ((s[size-1] &gt;= &apos;1&apos;) &amp;&amp; (s[size-1] &lt;= &apos;9&apos;)) {
        f[size-1] = 1;
    }

    for (int i = size - 2; i &gt;= 0; i--) {
        string key = string(1, s[i]);
        if ((map[key] &lt;= &apos;Z&apos;) &amp;&amp; (map[key] &gt;= &apos;A&apos;)) {
            f[i] += f[i+1];
        }
        key += s[i+1];
        if ((map[key] &lt;= &apos;Z&apos;) &amp;&amp; (map[key] &gt;= &apos;A&apos;)) {
            f[i] += f[i+2];
        }
    }

    return f[0];
}</code></pre>

</section>
<section	id="wordbreak">
<h3>Word Break</h3>

<blockquote>
<p>Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. </p>

<p>Note that the same word in the dictionary may be reused multiple times in the segmentation.</p>
</blockquote>

<ul>
<li>Recursion Solution</li>
</ul>
<pre><code class="cpp">bool wordBreakHelper(string&amp; s, vector&lt;string&gt;&amp; wordDict, int start) {
    if (start &gt;= s.size()) {
        return true;
    }

    for (int i = 0; i &lt; wordDict.size(); i++) {
        // rfind(s, the maximum index of start position)
        // std::string test = &quot;0123123&quot;;
        // size_t match1 = test.rfind(&quot;123&quot;);    // returns 4 (rightmost match)
        // size_t match2 = test.rfind(&quot;123&quot;, 2); // returns 1 (skipped over later match)
        // size_t match3 = test.rfind(&quot;123&quot;, 0); // returns std::string::npos (i.e. not found)
        // TODO: try all possible matches
        string str = s.substr(start);
        if (str.rfind(wordDict[i], 0) != string::npos) {
            if (wordBreakHelper(s, wordDict, start + wordDict[i].size())) {
                return true;
            }
        }
    }

    return false;
}

/**
 * @brief wordBreak_sol1
 * @param s
 * @param wordDict
 * @return
 * Think of it recursively.
 *
 * ex&gt; s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]
 * s will be seen as two parts s = &quot;segmented&quot; + &quot;unsegmented&quot;
 *
 * Define f as f(index): true if s[index..end] can be segmented with &apos;wordDict&apos;.
 *
 * Derivation: f(index): possible break word in &apos;wordDict&apos; + f(index + word.length).
 *                       false if no possible break word found.
 *
 * T: O(N^(M/avg(length of word))) if it is solved with recursion
 */
bool wordBreak_sol1(string s, vector&lt;string&gt;&amp; wordDict) {
    if (s.length() == 0) return true;
    if (wordDict.size() == 0) return false;

    bool result = wordBreakHelper(s, wordDict, 0);

    return result;
}</code></pre>

<ul>
<li>Dynamic Programming</li>
</ul>
<pre><code class="cpp">/**
 * @brief wordBreak_sol2
 * @param s
 * @param wordDict
 * @return
 * How to solve it in dynamic programming way? Similar to recursion.
 *
 * Define f as f(index): true if s[start..index] can be segmented with &apos;wordDict&apos;.
 *
 * ex&gt; s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]
 *
 * Derivation: f(index) = f(j) &amp;&amp; (s.sub(j, index-j)), where j is partitioning point for s[start..index]
 *
 * Base case: f(0) = true
 * 
 * T: O(N^3)
 */
bool wordBreak_sol2(string s, vector&lt;string&gt;&amp; wordDict) {
    unordered_set&lt;string&gt; set(wordDict.begin(), wordDict.end());
    vector&lt;bool&gt; breakable(s.length()+1, false);
    breakable[0] = true;

    for (int end = 1; end &lt;= s.length(); end++) {
        for (int partition = 0; partition &lt; end; partition++) {
            if ((breakable[partition]) &amp;&amp;
                (set.find(s.substr(partition, end-partition)) != set.end())) {
                breakable[end] = true;
                break;
            }
        }
    }

    return breakable[s.length()];
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Counterpart for <code>s.startswith()</code>: <code>s.rfind(pattern, end_pos)</code>, where end_pos is 0.</li>
<li>Base case is not necessarily starting from the beginning and it depends on the definition of function <code>f</code>.</li>
</ul>

</section>
<section	id="longestincreasingsubsequence">
<h3>Longest Increasing Subsequence</h3>

<blockquote>
<p>Given an integer array nums, return the length of the longest strictly increasing subsequence. </p>

<p>A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, <code>[3,6,2,7]</code> is a subsequence of the array <code>[0,3,1,6,2,2,7]</code>.</p>
</blockquote>

<ul>
<li>Dynamic Programming</li>
</ul>
<pre><code class="cpp">/**
 * @brief lengthOfLIS
 * @param nums
 * @return
 * The problem becomes clear when it is seen from the perspective of dynamic programming.
 *
 * ex&gt; nums = {0, 1, 0, 3, 2, 3}
 *
 * Think of the question: what&apos;s the longest subseq of nums + {1, 2, ...} when given the
 * longest subseq length is 4?
 *
 * Define f(end) as: the length of longest subseq ending with &apos;end&apos;.
 *
 * Derivation: f(end) = max(f[i] + 1) for all i where nums[i] &lt; nums[end] and i &lt; end
 *
 * Base case: f(i) = 1, where i belongs to [0, s.size()-1] as initially subseq ending with
 * all index is 1.
 *
 * T: O(N^2)
 */
int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0) return 0;
    int size = nums.size();

    vector&lt;int&gt; longest(size, 1);
    for (int end = 1; end &lt; size; end++) {
        for (int i = 0; i &lt; end; i++) {
            if ((nums[i] &lt; nums[end]) &amp;&amp; (longest[i] + 1 &gt; longest[end])){
                longest[end] = longest[i] + 1;
            }
        }
    }

    int max = 0;
    for (int i = 0; i &lt; size; i++) {
        if (longest[i] &gt; max) {
            max = longest[i];
        }
    }

    return max;
}</code></pre>

</section>
<section	id="dpsummary">
<h3>DP Summary</h3>

<p>Let&#8217;s make a short summary for dynamic programming.</p>

<ul>
<li>Realizing a Dynamic Programming Problem</li>
</ul>

<p>This problem has two important attributes that let us know it should be solved by dynamic programming. First, the question is asking for the maximum or minimum of something. Second, we have to make decisions that may depend on previously made decisions, which is very typical of a problem involving subsequences.</p>

<p>As we go through the input, each &#8220;decision&#8221; we must make is simple: is it worth it to consider this number? If we use a number, it may contribute towards an increasing subsequence, but it may also eliminate larger elements that came before it. For example, let&#8217;s say we have <code>nums = [5, 6, 7, 8, 1, 2, 3]</code>. It isn&#8217;t worth using the 1, 2, or 3, since using any of them would eliminate 5, 6, 7, and 8, which form the longest increasing subsequence. We can use dynamic programming to determine whether an element is worth using or not.</p>

<ul>
<li>A Framework to Solve Dynamic Programming Problems</li>
</ul>

<p>Typically, dynamic programming problems can be solved with three main components. If you&#8217;re new to dynamic programming, this might be hard to understand but is extremely valuable to learn since most dynamic programming problems can be solved this way.</p>

<p>First, we need some function or array that represents the answer to the problem from a given state. For many solutions on LeetCode, you will see this function/array named &#8220;dp&#8221;. For this problem, let&#8217;s say that we have an array dp. As just stated, this array needs to represent the answer to the problem for a given state, so let&#8217;s say that dp[i] represents the length of the longest increasing subsequence that ends with the <code>ith</code> element. The &#8220;state&#8221; is one-dimensional since it can be represented with only one variable - the index i.</p>

<p>Second, we need a way to transition between states, such as dp[5] and dp[7]. This is called a recurrence relation and can sometimes be tricky to figure out. Let&#8217;s say we know <code>dp[0]</code>, <code>dp[1]</code>, and <code>dp[2]</code>. How can we find <code>dp[3]</code> given this information? Well, since <code>dp[2]</code> represents the length of the longest increasing subsequence that ends with <code>nums[2]</code>, if <code>nums[3] &gt; nums[2]</code>, then we can simply take the subsequence ending at i = 2 and append <code>nums[3]</code> to it, increasing the length by 1. The same can be said for <code>nums[0]</code> and <code>nums[1]</code> if <code>nums[3]</code> is larger. Of course, we should try to maximize <code>dp[3]</code>, so we need to check all 3. Formally, the recurrence relation is: <code>dp[i] = max(dp[j] + 1)</code> for all j where <code>nums[j] &lt; nums[i]</code> and <code>j &lt; i</code>.</p>

</section>
<section	id="findnumberoflis">
<h3>Find Number of LIS</h3>

<blockquote>
<p>Given an integer array nums, return the number of longest increasing subsequences. </p>

<p>Notice that the sequence has to be strictly increasing.</p>
</blockquote>

<p>Based on the solution to the length of LIS, add vector <code>subseqs</code> to track paths to current ending index.</p>
<pre><code class="cpp">/**
 * @brief findNumberOfLIS
 * @param nums
 * @return
 * The solution is based on the algorithm for finding LIS. The difference is that we will
 * add additional information to f. We define f as:
 *
 * f(end) is same.
 * n(end), tracks the num of subseqs.
 */
int findNumberOfLIS(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0) return 0;
    int size = nums.size();

    vector&lt;int&gt; longest(size, 1);
    vector&lt;int&gt; subseqs(size, 1);
    for (int end = 1; end &lt; size; end++) {
        for (int i = 0; i &lt; end; i++) {
            if ((nums[i] &lt; nums[end]) &amp;&amp; (longest[i] + 1 &gt; longest[end])){
                longest[end] = longest[i] + 1;
            }
        }
        // track all subseqs
        int newCnt = 0;
        for (int i = 0; i &lt; end; i++) {
            if ((nums[i] &lt; nums[end]) &amp;&amp; ((longest[i] + 1) == longest[end])) {
                // if subseq[i] is connected to subseq[end]
                newCnt += subseqs[i];
            }
        }
        if (newCnt != 0) {
            subseqs[end] = newCnt;
        }
    }

    int max = 0;
    for (int i = 0; i &lt; size; i++) {
        if (longest[i] &gt; max) {
            max = longest[i];
        }
    }

    int cnt = 0;
    for (int i = 0; i &lt; size; i++) {
        if (longest[i] == max) {
            cnt += subseqs[i];
        }
    }

    return cnt;
}</code></pre>

</section>
<section	id="longestcommonsubsequence">
<h3>Longest Common Subsequence</h3>

<blockquote>
<p>Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. </p>

<p>A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. </p>

<ul>
<li>For example, &#8220;ace&#8221; is a subsequence of &#8220;abcde&#8221;.</li>
</ul>

<p>A common subsequence of two strings is a subsequence that is common to both strings.</p>
</blockquote>

<ul>
<li>Dynamic Programming</li>
</ul>
<pre><code class="cpp">/**
 * @brief longestCommonSubsequence
 * @param text1
 * @param text2
 * @return
 * When comes to dynamic programming, we define f as:
 *
 * f(i, j): the longest common subsequence of text1[0..i] and text2[0..j].
 *
 * Derivation: consider that how new coming characters text1[i] and text2[j] impact
 * f(i, j).
 *
 * case 1: if text1[i] == text2[j], f(i, j) = f(i-1, j-1) + 1.
 * case 2: otherwise, only text1[i] affects f(i, j), then f(i, j) = f(i, j-1)
 *                    only text2[j] affects f(i, j), then f(i, j) = f(i-1, j)
 *         to sum up, f(i, j) = max(f(i, j-1), f(i-1, j)).
 *
 * Base case:
 * f(0, 0) = 0;
 */
int longestCommonSubsequence(string text1, string text2) {
    if (text1.length() == 0) return 0;
    if (text2.length() == 0) return 0;
    int length1 = text1.size();
    int length2 = text2.size();
    vector&lt; vector&lt;int&gt; &gt; lcs(length1, vector&lt;int&gt;(length2, 0));
    // base case:
    bool include = false;
    for (int i = 0; i &lt; length1; i++) {
        if (!include) {
            if (text1[i] == text2[0]) {
                include = true;
                lcs[i][0] = 1;
            }
        }
        else {
            lcs[i][0] = 1;
        }
    }
    include = false;
    for (int j = 0; j &lt; length2; j++) {
        if (!include) {
            if (text1[0] == text2[j]) {
                include = true;
                lcs[0][j] = 1;
            }
        }
        else {
            lcs[0][j] = 1;
        }
    }

    for (int i = 1; i &lt; length1; i++) {
        for (int j = 1; j &lt; length2; j++) {
            if (text1[i] == text2[j]) {
                lcs[i][j] = lcs[i-1][j-1] + 1;
            }
            else {
                lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1]);
            }
        }
    }

    return lcs[length1-1][length2-1];
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Be careful for the edge condition.</li>
</ul>

</section>
<section	id="deleteoperationfortwostrings">
<h3>Delete Operation for Two Strings</h3>

<blockquote>
<p>Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same. </p>

<p>In one step, you can delete exactly one character in either string.</p>
</blockquote>

<p>The solution to this problem is based on LCS. <code># of operations = m + n - 2 * lcs</code></p>
<pre><code class="cpp">/**
 * @brief minDistance
 * @param word1
 * @param word2
 * @return
 * The problem can be converted as longest common subsequence problem.
 */
int minDistance(string word1, string word2) {
    if (word1.length() == 0) return 0;
    if (word2.length() == 0) return 0;
    int length1 = word1.size();
    int length2 = word2.size();
    vector&lt; vector&lt;int&gt; &gt; lcs(length1, vector&lt;int&gt;(length2, 0));
    // base case:
    bool include = false;
    for (int i = 0; i &lt; length1; i++) {
        if (!include) {
            if (word1[i] == word2[0]) {
                include = true;
                lcs[i][0] = 1;
            }
        }
        else {
            lcs[i][0] = 1;
        }
    }
    include = false;
    for (int j = 0; j &lt; length2; j++) {
        if (!include) {
            if (word1[0] == word2[j]) {
                include = true;
                lcs[0][j] = 1;
            }
        }
        else {
            lcs[0][j] = 1;
        }
    }

    for (int i = 1; i &lt; length1; i++) {
        for (int j = 1; j &lt; length2; j++) {
            if (word1[i] == word2[j]) {
                lcs[i][j] = lcs[i-1][j-1] + 1;
            }
            else {
                lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1]);
            }
        }
    }

    return length1 + length2 - 2 * lcs[length1-1][length2-1];
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Convert problems to solved problems.</li>
</ul>

</section>
<section	id="editdistance">
<h3>Edit Distance</h3>

<blockquote>
<p>Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. </p>

<p>You have the following three operations permitted on a word: </p>

<ul>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ul>
</blockquote>

<ul>
<li>Find longest common subsequence and operation on that.</li>
</ul>
<pre><code class="cpp">/**
 * @brief getLongestCommonSubsequence
 * @param src
 * @param dst
 * @param common: track common subsequence.
 */
void getLongestCommonSubsequence(string&amp; src, string&amp; dst, string&amp; common) {
    if (src.length() == 0) return;
    if (dst.length() == 0) return;
    int length1 = src.size();
    int length2 = dst.size();
    vector&lt; vector&lt;int&gt; &gt; lcs(length1, vector&lt;int&gt;(length2, 0));
    // base case:
    if (src[0] == dst[0]) {
        // 1. the first characters are equal.
        for (int i = 0; i &lt; length1; i++) {
            lcs[i][0] = 1;
        }
        for (int j = 0; j &lt; length2; j++) {
            lcs[0][j] = 1;
        }
    }
    else {
        // 2. not equal.
        bool include = false;
        // if any character in src is equal to dst[0], only the first equal works
        for (int i = 1; i &lt; length1; i++) {
            if ((!include) &amp;&amp; (src[i] == dst[0])) {
                include = true;
                lcs[i][0] = 1;
            }
            else {
                lcs[i][0] = lcs[i-1][0];
            }
        }
        include = false;
        // if any character in dst is equal to src[0]
        for (int j = 1; j &lt; length2; j++) {
            if ((!include) &amp;&amp; (src[0] == dst[j])) {
                include = true;
                lcs[0][j] = 1;
            }
            else {
                lcs[0][j] = lcs[0][j-1];
            }
        }
    }

    // TODO: derivation
    for (int i = 1; i &lt; length1; i++) {
        for (int j = 1; j &lt; length2; j++) {
            if (src[i] == dst[j]) {
                lcs[i][j] = lcs[i-1][j-1] + 1;
            }
            else {
                lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1]);
            }
        }
    }

    // TODO: backtrack - mirror derivation
    int i = src.size() - 1;
    int j = dst.size() - 1;
    while ((i &gt; 0) &amp;&amp; (j &gt; 0)) {
        if (src[i] == dst[j]) {
            common.push_back(src[i]);
            i--; j--;  // from lcs[i-1][j-1]
        }
        else {
            if (lcs[i-1][j] &gt;= lcs[i][j-1]) {
                i--;   // from lcs[i-1][j]
            }
            else {
                j--;   // from lcs[i][j-1]
            }
        }
    }

    if (common.size() &lt; lcs[src.size()-1][dst.size()-1]) {
        // first character
        if (src[0] == dst[0]) {
            common.push_back(src[0]);
        }
        else {
            if (i == 0) {
                // i == 0
                common.push_back(src[i]);
            }
            else {
                // j == 0
                common.push_back(dst[j]);
            }
        }
    }

    reverse(common.begin(), common.end());
}

/**
 * @brief minDistance_sol1
 * @param word1
 * @param word2
 * @return
 * We have to solve it with the help of Longest Common Subsequence (LCS).
 *
 * 1. find LCS
 * 2. transform: i points to the element in word1, j points the element in word2.
 *    - case 1: both word1[i] and word2[j] are in common subseq. Next.
 *    - case 2: word1[i] is not in common, and word2[j] is in common. Delete until word1[i]
 *    is in common.
 *    - case 3: both word1[i] and word2[i] are not in common subseq. Replace word1[i] with
 *    word2[j]
 *    - case 4: word1[i] is in common, and word2[j] is not in common. Insert word1[i] with
 *    word2[j] until word2[j] in common.
 *
 * ex&gt; word1(src) = &quot;extention&quot;  word2(dst) = &quot;execution&quot;  common = &quot;exetion&quot;
 *
 *    src: e x t e n t i o n
 *         ^   ^   ^ ^
 *         i  del  c ins(u)       distance = 3
 *    dst: e x e c u t i o n
 *         ^
 *         j
 * common: e x e t i o n
 *         ^
 *         k
 *
 * if src[i] == common[k], then src[i] is in common string.
 * if dst[j] == common[k], then dst[j] is in common string.
 *
 * T: O(N^2)
 */
int minDistance_sol1(string word1, string word2) {
    if (word1.length() == 0) return word2.length(); // insert
    if (word2.length() == 0) return word1.length(); // delete

    string src = word1;
    string dst = word2;
    string common;
    getLongestCommonSubsequence(src, dst, common);

    int opt_cnt = 0;
    int i = 0;
    int j = 0; // dst is unchanged
    int k = 0;
    while (j &lt; dst.length()) {
        if ((src[i] == common[k]) &amp;&amp; (dst[j] == common[k])) {
            // case 1:
            i++; j++; k++;
        }
        else if (src[i] == common[k]) {
            // case 3: insert s[i-1] with dst[j] until dst[j] is in common seq.
            // insert opt ...
            j++;
            opt_cnt++;
        }
        else if (dst[j] == common[k]) {
            // case 2: delete src[i] until src[i] is in common seq.
            // delete opt ...
            i++;
            opt_cnt++;
        }
        else {
            // case 4: replace src[i] with dst[j]
            src[i] = dst[j];
            i++; j++;
            opt_cnt++;
        }
    }

    // remove src&apos;s left
    while (i &lt; src.size()) {
        i++;
        opt_cnt++;
    }

    return opt_cnt;
}</code></pre>

<ul>
<li>Dynamic Programming</li>
</ul>
<pre><code class="cpp">/**
 * @brief minDistance_sol2
 * @param word1
 * @param word2
 * @return
 * Solution 2 is to build formula directly on minimum distance. Define f as:
 *
 * f(i, j) = the edit distance between word1[0..i] and word2[0..j]
 *
 * f(i, j) = when word1[i] == word2[j], f(i, j) = min(1 + f(i, j-1), 1 + f(i-1, j), f(i-1, j-1)).
 *         = when word1[i] != word2[j], f(i, j) = 1 + min(f(i, j-1), f(i-1, j), f(i-1, j-1)).
 *
 */
int minDistance_sol2(string word1, string word2) {
    if (word1.length() == 0) return word2.length();
    if (word2.length() == 0) return word1.length();

    vector&lt; vector&lt;int&gt; &gt; min_dis(word1.size(), vector&lt;int&gt;(word2.size(), INT_MAX));
    // Base case:
    if (word1[0] == word2[0]) {
        min_dis[0][0] = 0;
    }
    else {
        min_dis[0][0] = 1;
    }
    bool used = false; // only works for one set of equal characters
    for (int i = 1; i &lt; word1.size(); i++) {
        if ((!used) &amp;&amp; (word1[i] == word2[0])) {
            used = true;
            min_dis[i][0] = min_dis[i-1][0];
        }
        else {
           min_dis[i][0] = min_dis[i-1][0] + 1;
        }
    }
    used = false;
    for (int j = 1; j &lt; word2.size(); j++) {
        if ((!used) &amp;&amp; (word1[0] == word2[j])) {
            used = true;
            min_dis[0][j] = min_dis[0][j-1];
        }
        else {
            min_dis[0][j] = min_dis[0][j-1] + 1;
        }
    }

    // Derivation:
    for (int i = 1; i &lt; word1.size(); i++) {
        for (int j = 1; j &lt; word2.size(); j++) {
            min_dis[i][j] = 1 + min(min_dis[i-1][j], min_dis[i][j-1]);
            if (word1[i] == word2[j]) {
                min_dis[i][j] = min(min_dis[i][j], min_dis[i-1][j-1]);
            }
            else {
                min_dis[i][j] = min(min_dis[i][j], min_dis[i-1][j-1] + 1);
            }
        }
    }

    return min_dis[word1.length()-1][word2.length()-1];
}</code></pre>

<p>Tricks:</p>

<ul>
<li>How to backtrack the longest common subsequence? With the help of derivation formula.</li>
</ul>

</section>
<section	id="coinchange">
<h3>Coin Change</h3>

<blockquote>
<p>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. </p>

<p>Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return &#8211;1. </p>

<p>You may assume that you have an infinite number of each kind of coin.</p>
</blockquote>

<ul>
<li>Breath Search First</li>
</ul>
<pre><code class="cpp">/**
 * @brief coinChange_sol1
 * @param coins
 * @param amount
 * @return
 * To find the fewest number of coins that makes up &apos;amount&apos;, use BFS.
 *
 * ex&gt; {1, 2, 5}
 *
 * min_coin(11) = push(11 - 1), push(11 - 2), and push(11 - 5)
 * min_coin(10) = ...
 *
 * T: O(M^N)
 */
int coinChange_sol1(vector&lt;int&gt;&amp; coins, int amount) {
    if (amount == 0) return 0;
    if (coins.size() == 0) return -1;

    class QueueNode {
    public:
        int amount;
        int coin_cnt;
        QueueNode(int _amount, int _coin_cnt)
            : amount(_amount), coin_cnt(_coin_cnt) {}
    };

    queue&lt;QueueNode&gt; que;
    que.push(QueueNode(amount, 0));
    while (!que.empty()) {
        QueueNode cur = que.front();
        que.pop();

        if (cur.amount == 0) {
            return cur.coin_cnt;
        }

        if (cur.amount &gt; 0) {
            for (int i = 0; i &lt; coins.size(); i++) {
                que.push(QueueNode(cur.amount - coins[i], cur.coin_cnt + 1));
            }
        }
    }

    return -1;
}</code></pre>

<ul>
<li>Dynamic Programming</li>
</ul>
<pre><code class="cpp">/**
 * @brief coinChange_sol2
 * @param coins
 * @param amount
 * @return
 * How to handle it with dynamic programming, a more efficient way? Define f as:
 *
 * f(amount) is the fewest number of coins selected for making up &apos;amount&apos;.
 *
 * Derivation:
 * f(amount) = min(f(amount - coins[i])) + 1, where i is in range of coins.
 *
 * Base case:
 * Initialize all with INT_MAX.
 * f(0) = 0; f(coins[i]) = 1;
 *
 * T: O(N * M), where N is amount, M is the size of coins
 */
int coinChange_sol2(vector&lt;int&gt;&amp; coins, int amount) {
    if (amount == 0) return 0;
    if (coins.size() == 0) return -1;

    vector&lt;int&gt; min_coins(amount+1, INT_MAX);
    min_coins[0] = 0;
    for (int i = 0; i &lt; coins.size(); i++) {
        if (coins[i] &lt; min_coins.size()) {
            min_coins[coins[i]] = 1;
        }
    }

    for (int amt = 1; amt &lt; min_coins.size(); amt++) {
        for (int i = 0; i &lt; coins.size(); i++) {
            if (amt &gt;= coins[i]) {
                min_coins[amt] = min(min_coins[amt], min_coins[amt - coins[i]]);
            }
        }
        if (min_coins[amt] != INT_MAX) {
            min_coins[amt]++;
        }
    }

    if (min_coins[amount] == INT_MAX) {
        return -1;
    }

    return min_coins[amount];
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Bound check!!!</li>
</ul>

</section>
<section	id="integerbreak">
<h3>Integer Break</h3>

<blockquote>
<p>Given an integer n, break it into the sum of k positive integers, where k &gt;= 2, and maximize the product of those integers. </p>

<p>Return the maximum product you can get.</p>
</blockquote>

<p>Think of division recursively. What we care about is divide or not 2 divisors <code>i</code> and <code>num-i</code>.</p>
<pre><code class="cpp">/**
 * @brief integerBreak_sol2
 * @param n
 * @return
 * what we care about is just divide num into two number.
 *
 * f(num) = max of (max(i, f[i]) * max(num-i, f[num-i])), where i is in [1..num-1].
 *
 */
int integerBreak_sol2(int n) {
    if (n &lt; 2) return 0;
    vector&lt;int&gt; f(n+1, 0);

    for (int num = 2; num &lt; f.size(); num++) {
        int maximum = 0;
        for (int i = 1; i &lt; num; i++) {
            int cur = max(i, f[i]) * max(num - i, f[num-i]);
            if (cur &gt; maximum) {
                maximum = cur;
            }
        }
        f[num] = maximum;
    }

    return f[n];
}</code></pre>

</section>
</section>
<section	id="bitmanipulation">
<h2>Bit Manipulation</h2>

<section	id="rangebitwiseand">
<h3>Range Bitwise AND</h3>

<blockquote>
<p>Given two integers left and right that represent the range <code>[left, right]</code>, return the bitwise AND of all numbers in this range, inclusive.</p>
</blockquote>

<p>The equivalent question is to find the common prefix of <code>left</code> and <code>right</code>.</p>
<pre><code class="cpp">/**
 * @brief rangeBitwiseAnd
 * @param left
 * @param right
 * @return
 *
 * ex&gt; 9: 00001 001
 *    10: 00001 010
 *    11: 00001 011
 *    12: 00001 100
 *        |---|
 *    common prefix
 *
 * So the question can be transformed as how to find the common prefix of left and right.
 *
 * left   9: 00001 001
 *                   ^
 *                   i
 * right 12: 00001 100
 *                   ^
 *                   j
 *
 * Right shift until left[i] == right[j]
 *
 * T: O(1)
 */
int rangeBitwiseAnd(int left, int right) {
    if (left == 0) return 0;
    if (right == 0) return 0;

    int shift = 0;

    // right shift:  1  2  3
    // 1: 001        0  0  0
    // 5: 101       10  1  0


    while (left &lt; right) {
        left &gt;&gt;= 1;
        right &gt;&gt;= 1;
        shift++;
    }

    return left &lt;&lt; shift;
}</code></pre>

</section>
</section>
<section	id="others">
<h2>Others</h2>

<section	id="shuffleanarray">
<h3>Shuffle An Array</h3>

<blockquote>
<p>Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling. </p>

<p>Implement the <code>Solution</code> class: </p>

<ul>
<li><code>Solution(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>
<li><code>int[] reset()</code> Resets the array to its original configuration and returns it.</li>
<li><code>int[] shuffle()</code> Returns a random shuffling of the array.</li>
</ul>
</blockquote>

<p>How to generate a permutation of an array without enumerating all permuations. SWAP for <code>n</code> times.</p>
<pre><code class="cpp">class ShuffleAnArray
{
public:
    ShuffleAnArray(vector&lt;int&gt;&amp; _nums)
        : nums(_nums), origins(vector&lt;int&gt;(_nums)) {};
    vector&lt;int&gt; reset();
    vector&lt;int&gt; shuffle();

    vector&lt;int&gt;&amp; nums;
    vector&lt;int&gt; origins;
};

vector&lt;int&gt; ShuffleAnArray::reset() {
    for (int i = 0; i &lt; nums.size(); i++) {
        nums[i] = origins[i];
    }

    return nums;
}

vector&lt;int&gt; ShuffleAnArray::shuffle2() {
//    srand(time(NULL));
    int chosen;
    for (int i = 0; i &lt; nums.size(); i++) {
        chosen = rand() % nums.size();
        // swap nums[i] and nums[chosen]
        swap(nums[i], nums[chosen]);
    }

    return nums;
}</code></pre>

</section>
<section	id="happynumber">
<h3>Happy Number</h3>

<blockquote>
<p>Write an algorithm to determine if a number n is happy. </p>

<p>A happy number is a number defined by the following process: </p>

<ul>
<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>
<li>Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li>
<li>Those numbers for which this process ends in 1 are happy.</li>
</ul>

<p>Return true if n is a happy number, and false if not.</p>
</blockquote>

<p>There are three cases:</p>

<ul>
<li>It eventually gets to 1.</li>
<li>It eventually gets stuck in a cycle.</li>
<li>It keeps going higher and higher, up towards infinity. (not possible)</li>
</ul>

<p>Therefore, the core problem is how to detect cycle. Hashset or vector.</p>
<pre><code class="cpp">int next(int happy) {
    int newHappy = 0;
    while (happy &gt; 0) {
        int remainder = happy % 10;
        happy = happy / 10;
        newHappy += remainder * remainder;
    }

    return newHappy;
}

/**
 * @brief isHappy
 * @param n
 * @return true if it is happy.
 */
bool isHappy(int n) {
    vector&lt;bool&gt; memo(INT_MAX, false);
    if (n == 1) return true;
    int happy = n;
    while ((!memo[happy]) &amp;&amp; (happy != 1)) {
        memo[happy] = true;
        happy = next(happy);
    }

    return happy == 1;
}</code></pre>

<p>But there is a more tricky way - the power of math. There is only one cycle in fact.</p>
<pre><code class="cpp">/**
 * @brief isHappy_sol2
 * @param n
 * @return
 * magic math solution: there is only one cycle:
 *
 * 4 - 16 - 37 - 58 - 89 - 145 - 42 - 20 - 4
 *
 * So hardcode it.
 */
bool isHappy_sol2(int n) {
    unordered_set&lt;int&gt; cycle = {4, 16, 37, 58, 89, 145, 42, 20};
    if (n == 1) return true;
    int happy = n;

    while ((happy != 1) &amp;&amp; (cycle.find(happy) == cycle.end())) {
        happy = next(happy);
    }

    return happy == 1;
}</code></pre>

<p>Tricks:</p>

<ul>
<li>Power of math.</li>
<li>Carefully design the order of conditions for loop.</li>
</ul>

</section>
</section>
<p><EndMarkdown></p>
